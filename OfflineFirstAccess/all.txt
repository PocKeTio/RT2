Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\ChangeTracking\ChangeTracker.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data.OleDb;
using System.Linq;
using System.Threading.Tasks;
using OfflineFirstAccess.Data;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.ChangeTracking
{
    public class ChangeTracker : IChangeTracker
    {
        private readonly string _localConnectionString;
        private const string ChangeLogTableName = "_ChangeLog";

        public ChangeTracker(string localConnectionString)
        {
            _localConnectionString = localConnectionString;
        }

        public async Task RecordChangeAsync(string tableName, string rowGuid, string operationType)
        {
            var query = $"INSERT INTO [{ChangeLogTableName}] (TableName, RowGuid, OperationType, TimestampUTC, IsSynced) VALUES (@TableName, @RowGuid, @OperationType, @TimestampUTC, @IsSynced)";

            using (var connection = new OleDbConnection(_localConnectionString))
            {
                await connection.OpenAsync();
                using (var command = new OleDbCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@TableName", tableName);
                    command.Parameters.AddWithValue("@RowGuid", rowGuid);
                    command.Parameters.AddWithValue("@OperationType", operationType);
                    command.Parameters.AddWithValue("@TimestampUTC", DateTime.UtcNow);
                    command.Parameters.AddWithValue("@IsSynced", false);
                    await command.ExecuteNonQueryAsync();
                }
            }
        }

        public async Task<IEnumerable<ChangeLogEntry>> GetUnsyncedChangesAsync()
        {
            var entries = new List<ChangeLogEntry>();
            var query = $"SELECT ID, TableName, RowGuid, OperationType, TimestampUTC FROM [{ChangeLogTableName}] WHERE IsSynced = false ORDER BY TimestampUTC";

            using (var connection = new OleDbConnection(_localConnectionString))
            {
                await connection.OpenAsync();
                using (var command = new OleDbCommand(query, connection))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        while (await reader.ReadAsync())
                        {
                            entries.Add(new ChangeLogEntry
                            {
                                Id = Convert.ToInt64(reader["ID"]),
                                TableName = reader["TableName"].ToString(),
                                RowGuid = reader["RowGuid"].ToString(),
                                OperationType = reader["OperationType"].ToString(),
                                TimestampUTC = Convert.ToDateTime(reader["TimestampUTC"])
                            });
                        }
                    }
                }
            }
            return entries;
        }

        public async Task MarkChangesAsSyncedAsync(IEnumerable<long> changeIds)
        {
            if (!changeIds.Any())
                return;

            var parameterPlaceholders = string.Join(",", changeIds.Select((_, i) => $"@p{i}"));
            var query = $"UPDATE [{ChangeLogTableName}] SET IsSynced = true WHERE ID IN ({parameterPlaceholders})";

            using (var connection = new OleDbConnection(_localConnectionString))
            {
                await connection.OpenAsync();
                using (var command = new OleDbCommand(query, connection))
                {
                    int i = 0;
                    foreach (var id in changeIds)
                    {
                        command.Parameters.AddWithValue($"@p{i++}", id);
                    }
                    await command.ExecuteNonQueryAsync();
                }
            }
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\ChangeTracking\IChangeTracker.cs
--------------------------------------------------
using System.Collections.Generic;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.ChangeTracking
{
    /// <summary>
    /// Defines operations for tracking data changes.
    /// </summary>
    public interface IChangeTracker
    {
        /// <summary>
        /// Records a change made to a record.
        /// </summary>
        Task RecordChangeAsync(string tableName, string rowGuid, string operationType);

        /// <summary>
        /// Retrieves all changes that have not yet been synchronized.
        /// </summary>
        Task<IEnumerable<ChangeLogEntry>> GetUnsyncedChangesAsync();

        /// <summary>
        /// Marks a set of changes as synchronized.
        /// </summary>
        Task MarkChangesAsSyncedAsync(IEnumerable<long> changeIds);
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Conflicts\IConflictResolver.cs
--------------------------------------------------
using System.Collections.Generic;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;
using GenericRecord = System.Collections.Generic.Dictionary<string, object>;

namespace OfflineFirstAccess.Conflicts
{
    /// <summary>
    /// Defines a strategy for detecting and resolving data conflicts.
    /// </summary>
    public interface IConflictResolver
    {
        /// <summary>
        /// Separates incoming changes into conflicts and non-conflicts.
        /// </summary>
        Task<(List<Conflict> conflicts, List<GenericRecord> nonConflicts)> DetectConflicts(
            IEnumerable<GenericRecord> remoteChanges, IEnumerable<ChangeLogEntry> localUnsyncedChanges);

        /// <summary>
        /// Applies a strategy to resolve identified conflicts.
        /// </summary>
        Task<IEnumerable<GenericRecord>> Resolve(List<Conflict> conflicts);
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Conflicts\ManualConflictResolver.cs
--------------------------------------------------
using System.Collections.Generic;
using System.Linq;
using OfflineFirstAccess.Configuration;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Conflicts
{
    public class ManualConflictResolver : IConflictResolver
    {
        public ManualConflictResolver(SyncConfiguration config)
        {
            // Constructor required by SynchronizationService, but not used for now.
        }
        public (List<Conflict> conflicts, List<Dictionary<string, object>> nonConflicts) DetectConflicts(IEnumerable<Dictionary<string, object>> remoteChanges, IEnumerable<ChangeLogEntry> localChanges)
        {
            var conflicts = new List<Conflict>();
            var nonConflicts = new List<Dictionary<string, object>>();
            var localChangesDict = localChanges.ToDictionary(c => c.RowGuid);

            foreach (var remoteChange in remoteChanges)
            {
                // In the new SyncOrchestrator logic, this method only receives potential conflicts.
                var remoteGuid = remoteChange["guid"].ToString();
                if (localChangesDict.TryGetValue(remoteGuid, out var localChange))
                {
                    conflicts.Add(new Conflict(localChange.GetAsDictionary(), remoteChange));
                }
                else
                {
                    // This case should not happen, but as a safeguard, treat as non-conflict.
                    nonConflicts.Add(remoteChange);
                }
            }
            return (conflicts, nonConflicts);
        }

        public IEnumerable<Dictionary<string, object>> ResolveConflicts(IEnumerable<Conflict> conflicts)
        {
            // Manual resolution strategy: return no resolved items.
            // The conflicts are expected to be handled by the application layer.
            return Enumerable.Empty<Dictionary<string, object>>();
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Data\AccessDataProvider.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data.OleDb;
using System.Linq;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;

using GenericRecord = System.Collections.Generic.Dictionary<string, object>;

namespace OfflineFirstAccess.Data
{
    public class AccessDataProvider : IDataProvider
    {
        private readonly string _connectionString;
        private readonly SyncConfiguration _config;

        public AccessDataProvider(string connectionString, SyncConfiguration config)
        {
            _connectionString = connectionString;
            _config = config;
            // This is a blocking call, which is not ideal in a constructor.
            // In a real-world app, an async factory pattern or an explicit InitializeAsync() method would be better.
            EnsureConfigTableExistsAsync().GetAwaiter().GetResult();
        }

        public async Task<IEnumerable<GenericRecord>> GetChangesAsync(string tableName, DateTime? since)
        {
            var records = new List<GenericRecord>();
            var query = $"SELECT * FROM [{tableName}] WHERE [{_config.LastModifiedColumn}] > @lastSync";

            using (var connection = new OleDbConnection(_connectionString))
            {
                await connection.OpenAsync();
                using (var command = new OleDbCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@lastSync", since ?? DateTime.MinValue);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        while (await reader.ReadAsync())
                        {
                            var record = new GenericRecord();
                            for (int i = 0; i < reader.FieldCount; i++)
                            {
                                record[reader.GetName(i)] = reader.GetValue(i);
                            }
                            records.Add(record);
                        }
                    }
                }
            }
            return records;
        }

        public async Task ApplyChangesAsync(string tableName, IEnumerable<GenericRecord> changesToApply)
        {
            if (changesToApply == null || !changesToApply.Any())
            {
                return;
            }

            using (var connection = new OleDbConnection(_connectionString))
            {
                await connection.OpenAsync();
                using (var transaction = connection.BeginTransaction())
                {
                    try
                    {
                        foreach (var record in changesToApply)
                        {
                            var isDeleted = record.ContainsKey(_config.IsDeletedColumn) && (bool)record[_config.IsDeletedColumn];
                            var guid = record[_config.PrimaryKeyGuidColumn].ToString();

                            if (isDeleted)
                            {
                                var deleteSql = $"DELETE FROM [{tableName}] WHERE [{_config.PrimaryKeyGuidColumn}] = @guid";
                                using (var command = new OleDbCommand(deleteSql, connection, transaction))
                                {
                                    command.Parameters.AddWithValue("@guid", guid);
                                    await command.ExecuteNonQueryAsync();
                                }
                            }
                            else
                            {
                                // Optimized Upsert logic: Try UPDATE first, then INSERT.
                                var updateSetClause = string.Join(", ", record.Keys.Where(k => k != _config.PrimaryKeyGuidColumn).Select(k => $"[{k}] = @{k}"));
                                var updateSql = $"UPDATE [{tableName}] SET {updateSetClause} WHERE [{_config.PrimaryKeyGuidColumn}] = @guid";
                                int rowsAffected;

                                using (var updateCommand = new OleDbCommand(updateSql, connection, transaction))
                                {
                                    foreach (var key in record.Keys.Where(k => k != _config.PrimaryKeyGuidColumn))
                                    {
                                        updateCommand.Parameters.AddWithValue($"@{key}", record[key] ?? DBNull.Value);
                                    }
                                    updateCommand.Parameters.AddWithValue("@guid", guid);
                                    rowsAffected = await updateCommand.ExecuteNonQueryAsync();
                                }

                                if (rowsAffected == 0)
                                {
                                    // If no rows were updated, the record doesn't exist. Insert it.
                                    var insertColumns = string.Join(", ", record.Keys.Select(k => $"[{k}]"));
                                    var insertValues = string.Join(", ", record.Keys.Select(k => $"@{k}"));
                                    var insertSql = $"INSERT INTO [{tableName}] ({insertColumns}) VALUES ({insertValues})";
                                    using (var insertCommand = new OleDbCommand(insertSql, connection, transaction))
                                    {
                                        foreach (var key in record.Keys)
                                        {
                                            insertCommand.Parameters.AddWithValue($"@{key}", record[key] ?? DBNull.Value);
                                        }
                                        await insertCommand.ExecuteNonQueryAsync();
                                    }
                                }
                            }
                        }
                        transaction.Commit();
                    }
                    catch
                    {
                        transaction.Rollback();
                        throw;
                    }
                }
            }
        }

        public async Task<IEnumerable<GenericRecord>> GetRecordsByGuid(string tableName, IEnumerable<string> guids)
        {
            var records = new List<GenericRecord>();
            if (!guids.Any())
                return records;

            var parameterPlaceholders = string.Join(",", guids.Select((_, i) => $"@p{i}"));
            var query = $"SELECT * FROM [{tableName}] WHERE [{_config.PrimaryKeyGuidColumn}] IN ({parameterPlaceholders})";

            using (var connection = new OleDbConnection(_connectionString))
            {
                await connection.OpenAsync();
                using (var command = new OleDbCommand(query, connection))
                {
                    int i = 0;
                    foreach (var guid in guids)
                    {
                        command.Parameters.AddWithValue($"@p{i++}", guid);
                    }

                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        while (await reader.ReadAsync())
                        {
                            var record = new GenericRecord();
                            for (int j = 0; j < reader.FieldCount; j++)
                            {
                                record[reader.GetName(j)] = reader.GetValue(j);
                            }
                            records.Add(record);
                        }
                    }
                }
            }
            return records;
        }
        public async Task<string> GetParameterAsync(string key)
        {
            using (var connection = new OleDbConnection(_connectionString))
            {
                await connection.OpenAsync();
                var command = new OleDbCommand("SELECT ConfigValue FROM _SyncConfig WHERE ConfigKey = @Key", connection);
                command.Parameters.AddWithValue("@Key", key);
                var result = await command.ExecuteScalarAsync();
                return result?.ToString();
            }
        }

        public async Task SetParameterAsync(string key, string value)
        {
            using (var connection = new OleDbConnection(_connectionString))
            {
                await connection.OpenAsync();
                
                var updateCommand = new OleDbCommand("UPDATE _SyncConfig SET ConfigValue = @Value WHERE ConfigKey = @Key", connection);
                updateCommand.Parameters.AddWithValue("@Value", value);
                updateCommand.Parameters.AddWithValue("@Key", key);
                int rowsAffected = await updateCommand.ExecuteNonQueryAsync();

                if (rowsAffected == 0)
                {
                    var insertCommand = new OleDbCommand("INSERT INTO _SyncConfig (ConfigKey, ConfigValue) VALUES (@Key, @Value)", connection);
                    insertCommand.Parameters.AddWithValue("@Key", key);
                    insertCommand.Parameters.AddWithValue("@Value", value);
                    await insertCommand.ExecuteNonQueryAsync();
                }
            }
        }

        private async Task EnsureConfigTableExistsAsync()
        {
            try
            {
                using (var connection = new OleDbConnection(_connectionString))
                {
                    await connection.OpenAsync();
                    var schema = await connection.GetOleDbSchemaTableAsync(OleDbSchemaGuid.Tables, new object[] { null, null, null, "TABLE" });
                    bool tableExists = schema.Rows.OfType<DataRow>().Any(r => r["TABLE_NAME"].ToString().Equals("_SyncConfig", StringComparison.OrdinalIgnoreCase));

                    if (!tableExists)
                    {
                        var createCommand = new OleDbCommand("CREATE TABLE _SyncConfig (ConfigKey TEXT(255) PRIMARY KEY, ConfigValue MEMO)", connection);
                        await createCommand.ExecuteNonQueryAsync();
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error ensuring _SyncConfig table exists: {ex.Message}");
                // In a real app, this should be logged to a proper logging framework.
            }
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Data\IDataProvider.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

// Represents a record in a generic way
using GenericRecord = System.Collections.Generic.Dictionary<string, object>;

namespace OfflineFirstAccess.Data
{
    /// <summary>
    /// Defines atomic operations for reading and writing data from a data source.
    /// </summary>
    public interface IDataProvider
    {
        /// <summary>
        /// Retrieves records that have changed since a specific point in time.
        /// </summary>
        Task<IEnumerable<GenericRecord>> GetChangesAsync(string tableName, DateTime? since);

        /// <summary>
        /// Applies a set of changes (inserts, updates, deletes) to a table.
        /// </summary>
        Task ApplyChangesAsync(string tableName, IEnumerable<GenericRecord> changesToApply);

        /// <summary>
        /// Retrieves full records based on their GUIDs.
        /// </summary>
        Task<IEnumerable<GenericRecord>> GetRecordsByGuid(string tableName, IEnumerable<string> guids);

        /// <summary>
        /// Retrieves a configuration parameter value from the database.
        /// </summary>
        Task<string> GetParameterAsync(string key);

        /// <summary>
        /// Sets a configuration parameter value in the database.
        /// </summary>
        Task SetParameterAsync(string key, string value);
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\ConfigConstants.cs
--------------------------------------------------
using System;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Constantes pour la configuration de l'application
    /// </summary>
    public static class ConfigConstants
    {
        // Constantes pour le cache d'entités
        public static class EntityCache
        {
            public const string ExpirationMinutes = "EntityCacheExpirationMinutes";
            public const string MaxSize = "EntityCacheMaxSize";
            public const string CleanupIntervalMinutes = "EntityCacheCleanupIntervalMinutes";
            
            // Valeurs par défaut
            public const int DefaultExpirationMinutes = 15;
            public const int DefaultMaxSize = 1000;
            public const int DefaultCleanupIntervalMinutes = 5;
        }
        
        // Constantes pour le gestionnaire de batch adaptatif
        public static class BatchSize
        {
            public const string MinSize = "SyncMinBatchSize";
            public const string MaxSize = "SyncMaxBatchSize";
            public const string InitialSize = "SyncInitialBatchSize";
            public const string Increment = "SyncBatchSizeIncrement";
            public const string Decrement = "SyncBatchSizeDecrement";
            public const string SuccessThreshold = "SyncSuccessThreshold";
            public const string FailureThreshold = "SyncFailureThreshold";
            
            // Valeurs par défaut
            public const int DefaultMinSize = 10;
            public const int DefaultMaxSize = 200;
            public const int DefaultInitialSize = 50;
            public const int DefaultIncrement = 20;
            public const int DefaultDecrement = 30;
            public const int DefaultSuccessThreshold = 3;
            public const int DefaultFailureThreshold = 1;
        }
        
        // Constantes pour la synchronisation
        public static class Sync
        {
            public const string LockTimeoutSeconds = "SyncLockTimeoutSeconds";
            public const string LogRetentionDays = "ChangeLogRetentionDays";
            public const string PushBatchSize = "PushBatchSize";
            public const string PullBatchSize = "PullBatchSize";
            public const string TableBatchSize = "TableBatchSize";
            public const string ConflictBatchSize = "ConflictBatchSize";
            
            // Valeurs par défaut
            public const int DefaultLockTimeoutSeconds = 30;
            public const int DefaultLogRetentionDays = 30;
            public const int DefaultBatchSize = 50;
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\DatabaseTemplateBuilder.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Classe facilitant la création de bases de données template avec une API fluide
    /// </summary>
    public class DatabaseTemplateBuilder
    {
        private readonly DatabaseConfiguration _config;
        private readonly string _templatePath;

        /// <summary>
        /// Crée un nouveau builder de template de base de données
        /// </summary>
        /// <param name="templatePath">Chemin où la base de données template sera créée</param>
        public DatabaseTemplateBuilder(string templatePath)
        {
            _templatePath = templatePath ?? throw new ArgumentNullException(nameof(templatePath));
            _config = new DatabaseConfiguration
            {
                LocalStoragePath = Path.GetDirectoryName(templatePath)
            };
            
            // Ajouter les tables système par défaut
            AddSystemTables();
        }

        /// <summary>
        /// Ajoute les tables système nécessaires au fonctionnement offline-first
        /// </summary>
        private void AddSystemTables()
        {
            // CORRECTION : ChangeLog supprimé - maintenant géré dans la base Lock
            // ChangeLog est créé automatiquement via EnsureChangeLogTableExistsAsync

            // Table des verrous (SyncLocks)
            AddTable("SyncLocks")
                .WithPrimaryKey("LockID", typeof(string), false)
                .WithColumn("UserID", typeof(string), false)
                .WithColumn("LockTime", typeof(DateTime), false)
                .WithColumn("ExpiresAt", typeof(DateTime), false);

            // Table des sessions (Sessions)
            AddTable("Sessions")
                .WithPrimaryKey("SessionID", typeof(string), false)
                .WithColumn("UserID", typeof(string), false)
                .WithColumn("MachineName", typeof(string), false)
                .WithColumn("StartTime", typeof(DateTime), false)
                .WithColumn("LastActivity", typeof(DateTime), false)
                .WithColumn("IsActive", typeof(bool), false);
        }

        /// <summary>
        /// Commence la définition d'une nouvelle table
        /// </summary>
        /// <param name="tableName">Nom de la table</param>
        /// <returns>Un builder de table pour configurer la table</returns>
        public TableBuilder AddTable(string tableName)
        {
            return new TableBuilder(this, tableName);
        }

        /// <summary>
        /// Crée la base de données template avec la structure définie
        /// </summary>
        /// <returns>True si la création a réussi, False sinon</returns>
        public async Task<bool> CreateTemplateAsync()
        {
            return await DatabaseTemplateGenerator.CreateDatabaseTemplateAsync(_templatePath, _config);
        }

        /// <summary>
        /// Vérifie si une base de données existante correspond à la structure définie
        /// </summary>
        /// <param name="databasePath">Chemin de la base de données à vérifier</param>
        /// <returns>True si la structure correspond, False sinon</returns>
        public async Task<bool> ValidateDatabaseAsync(string databasePath)
        {
            return await DatabaseTemplateGenerator.ValidateDatabaseStructureAsync(databasePath, _config);
        }

        /// <summary>
        /// Met à jour la structure d'une base de données existante pour correspondre à la structure définie
        /// </summary>
        /// <param name="databasePath">Chemin de la base de données à mettre à jour</param>
        /// <returns>True si la mise à jour a réussi, False sinon</returns>
        public async Task<bool> UpdateDatabaseAsync(string databasePath)
        {
            return await DatabaseTemplateGenerator.UpdateDatabaseStructureAsync(databasePath, _config);
        }

        /// <summary>
        /// Obtient la configuration de base de données générée
        /// </summary>
        /// <returns>La configuration de base de données</returns>
        public DatabaseConfiguration GetConfiguration()
        {
            return _config;
        }

        /// <summary>
        /// Builder pour configurer une table
        /// </summary>
        public class TableBuilder
        {
            private readonly DatabaseTemplateBuilder _parentBuilder;
            private readonly TableConfiguration _tableConfig;

            internal TableBuilder(DatabaseTemplateBuilder parentBuilder, string tableName)
            {
                _parentBuilder = parentBuilder;
                _tableConfig = new TableConfiguration
                {
                    Name = tableName,
                    Columns = new List<ColumnDefinition>()
                };
            }

            /// <summary>
            /// Définit la colonne de clé primaire de la table
            /// </summary>
            /// <param name="columnName">Nom de la colonne</param>
            /// <param name="dataType">Type de données</param>
            /// <param name="autoIncrement">Indique si la colonne est auto-incrémentée</param>
            /// <returns>Le builder de table pour chaîner les appels</returns>
            public TableBuilder WithPrimaryKey(string columnName, Type dataType, bool autoIncrement = false)
            {
                _tableConfig.PrimaryKeyColumn = columnName;
                _tableConfig.PrimaryKeyType = dataType;

                _tableConfig.Columns.Add(new ColumnDefinition(
                    columnName,
                    dataType,
                    GetSqlType(dataType),
                    false,
                    true,
                    autoIncrement
                ));

                return this;
            }

            /// <summary>
            /// Ajoute une colonne à la table
            /// </summary>
            /// <param name="columnName">Nom de la colonne</param>
            /// <param name="dataType">Type de données</param>
            /// <param name="isNullable">Indique si la colonne peut être nulle</param>
            /// <returns>Le builder de table pour chaîner les appels</returns>
            public TableBuilder WithColumn(string columnName, Type dataType, bool isNullable = true)
            {
                _tableConfig.Columns.Add(new ColumnDefinition(
                    columnName,
                    dataType,
                    GetSqlType(dataType),
                    isNullable,
                    false,
                    false
                ));

                return this;
            }

            /// <summary>
            /// Définit la colonne de date de dernière modification
            /// </summary>
            /// <param name="columnName">Nom de la colonne (par défaut: LastModified)</param>
            /// <returns>Le builder de table pour chaîner les appels</returns>
            public TableBuilder WithLastModifiedColumn(string columnName = "LastModified")
            {
                _tableConfig.LastModifiedColumn = columnName;

                // S'assurer que la colonne existe
                if (!_tableConfig.Columns.Exists(c => c.Name == columnName))
                {
                    _tableConfig.Columns.Add(new ColumnDefinition(
                        columnName,
                        typeof(DateTime),
                        "DATETIME",
                        false,
                        false,
                        false
                    ));
                }

                return this;
            }

            /// <summary>
            /// Termine la définition de la table et retourne au builder de template
            /// </summary>
            /// <returns>Le builder de template pour continuer la configuration</returns>
            public DatabaseTemplateBuilder EndTable()
            {
                // Générer le SQL de création de table
                GenerateCreateTableSql();

                // Ajouter la table à la configuration
                int existingIndex = _parentBuilder._config.Tables.FindIndex(t => t.Name == _tableConfig.Name);
                if (existingIndex >= 0)
                {
                    _parentBuilder._config.Tables[existingIndex] = _tableConfig;
                }
                else
                {
                    _parentBuilder._config.Tables.Add(_tableConfig);
                }

                return _parentBuilder;
            }

            /// <summary>
            /// Génère le SQL de création de table
            /// </summary>
            private void GenerateCreateTableSql()
            {
                var columnDefs = new List<string>();

                foreach (var column in _tableConfig.Columns)
                {
                    var columnDef = $"{column.Name} {column.SqlType}";

                    if (column.IsPrimaryKey && !column.IsAutoIncrement)
                        columnDef += " PRIMARY KEY";

                    if (column.IsAutoIncrement)
                        columnDef = column.Name + " COUNTER PRIMARY KEY";

                    if (!column.IsNullable)
                        columnDef += " NOT NULL";

                    columnDefs.Add(columnDef);
                }

                _tableConfig.CreateTableSql = $"CREATE TABLE {_tableConfig.Name} (\n    " +
                                             string.Join(",\n    ", columnDefs) +
                                             "\n)";
            }

            /// <summary>
            /// Convertit un type .NET en type SQL Access
            /// </summary>
            /// <param name="type">Type .NET</param>
            /// <returns>Type SQL Access correspondant</returns>
            private string GetSqlType(Type type)
            {
                if (type == typeof(int) || type == typeof(long))
                    return "INTEGER";
                if (type == typeof(string))
                    return "TEXT(255)";
                if (type == typeof(DateTime))
                    return "DATETIME";
                if (type == typeof(bool))
                    return "BIT";
                if (type == typeof(decimal) || type == typeof(double) || type == typeof(float))
                    return "DOUBLE";
                if (type == typeof(byte[]))
                    return "BINARY";
                if (type == typeof(Guid))
                    return "TEXT(36)";

                return "TEXT(255)";
            }
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\DatabaseTemplateFactory.cs
--------------------------------------------------
using System;
using System.IO;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Classe utilitaire pour créer facilement des bases de données template
    /// </summary>
    public static class DatabaseTemplateFactory
    {
        /// <summary>
        /// Crée une base de données template standard avec les tables système
        /// </summary>
        /// <param name="templatePath">Chemin où la base de données template sera créée</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateStandardTemplateAsync(string templatePath)
        {
            var builder = new DatabaseTemplateBuilder(templatePath);
            return await builder.CreateTemplateAsync();
        }

        /// <summary>
        /// Crée une base de données template personnalisée
        /// </summary>
        /// <param name="templatePath">Chemin où la base de données template sera créée</param>
        /// <param name="configureAction">Action permettant de configurer la structure de la base de données</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateCustomTemplateAsync(string templatePath, Action<DatabaseTemplateBuilder> configureAction)
        {
            var builder = new DatabaseTemplateBuilder(templatePath);
            
            // Appliquer la configuration personnalisée
            configureAction?.Invoke(builder);
            
            return await builder.CreateTemplateAsync();
        }

        /// <summary>
        /// Crée une base de données template à partir d'une configuration existante
        /// </summary>
        /// <param name="templatePath">Chemin où la base de données template sera créée</param>
        /// <param name="config">Configuration définissant la structure de la base de données</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateFromConfigurationAsync(string templatePath, DatabaseConfiguration config)
        {
            return await DatabaseTemplateGenerator.CreateDatabaseTemplateAsync(templatePath, config);
        }

        /// <summary>
        /// Crée une base de données référentielle commune avec les tables de référence Ambre et utilisateur
        /// </summary>
        /// <param name="templatePath">Chemin où la base de données référentielle sera créée</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateReferentialTemplateAsync(string templatePath)
        {
            var builder = new DatabaseTemplateBuilder(templatePath);
            
            // Table T_Ref_Ambre_ImportFields
            builder.AddTable("T_Ref_Ambre_ImportFields")
                .WithColumn("AMB_Source", typeof(string), false)
                .WithColumn("AMB_Destination", typeof(string), false);
            
            // Table T_Ref_Ambre_TransactionCodes
            builder.AddTable("T_Ref_Ambre_TransactionCodes")
                .WithPrimaryKey("ID", typeof(int), true)
                .WithColumn("CODE", typeof(string), false)
                .WithColumn("TAG", typeof(string), false);
            
            // Table T_Ref_Ambre_Transform
            builder.AddTable("T_Ref_Ambre_Transform")
                .WithColumn("AMB_Source", typeof(string), false)
                .WithColumn("AMB_Destination", typeof(string), false)
                .WithColumn("AMB_TransformationFunction", typeof(string), false)
                .WithColumn("AMB_Description", typeof(string), true);
            
            // Table T_Ref_User_Fields
            builder.AddTable("T_Ref_User_Fields")
                .WithPrimaryKey("ID", typeof(int), true)
                .WithColumn("Category", typeof(string), false)
                .WithColumn("FieldName", typeof(string), false)
                .WithColumn("FieldDescription", typeof(string), true)
                .WithColumn("Pivot", typeof(bool), false)
                .WithColumn("Receivable", typeof(bool), false)
                .WithColumn("IsClickable", typeof(bool), false);
            
            // Table T_Ref_Country
            builder.AddTable("T_Ref_Country")
                .WithPrimaryKey("CNT_Id", typeof(string), false)
                .WithColumn("CNT_Name", typeof(string), false)
                .WithColumn("CNT_AmbreCountryId", typeof(int), true)
                .WithColumn("CNT_AmbrePivot", typeof(string), true)
                .WithColumn("CNT_AmbreReceivable", typeof(string), true)
                .WithColumn("CNT_AmbrePivotCountry", typeof(int), true)
                .WithColumn("CNT_ServiceCode", typeof(string), true)
                .WithColumn("CNT_BIC", typeof(string), true);
            
            return await builder.CreateTemplateAsync();
        }

        /// <summary>
        /// Crée une base de données template à partir d'une base de données existante
        /// </summary>
        /// <param name="sourceDatabasePath">Chemin de la base de données source</param>
        /// <param name="templatePath">Chemin où la base de données template sera créée</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static bool CreateFromExistingDatabase(string sourceDatabasePath, string templatePath)
        {
            try
            {
                // Vérifier que la base de données source existe
                if (!File.Exists(sourceDatabasePath))
                    return false;

                // Créer le répertoire de destination si nécessaire
                string directory = Path.GetDirectoryName(templatePath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Copier la base de données source vers le template
                File.Copy(sourceDatabasePath, templatePath, true);

                return true;
            }
            catch (Exception ex)
            {
                LogManager.Error($"Erreur lors de la création du template à partir d'une base existante : {ex.Message}", ex);
                return false;
            }
        }

        /// <summary>
        /// Vérifie si une base de données existante correspond à un template standard
        /// </summary>
        /// <param name="databasePath">Chemin de la base de données à vérifier</param>
        /// <returns>True si la structure correspond, False sinon</returns>
        public static async Task<bool> ValidateStandardStructureAsync(string databasePath)
        {
            var builder = new DatabaseTemplateBuilder(Path.GetTempFileName());
            return await builder.ValidateDatabaseAsync(databasePath);
        }

        /// <summary>
        /// Met à jour la structure d'une base de données existante pour correspondre à un template standard
        /// </summary>
        /// <param name="databasePath">Chemin de la base de données à mettre à jour</param>
        /// <returns>True si la mise à jour a réussi, False sinon</returns>
        public static async Task<bool> UpdateToStandardStructureAsync(string databasePath)
        {
            var builder = new DatabaseTemplateBuilder(Path.GetTempFileName());
            return await builder.UpdateDatabaseAsync(databasePath);
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\DatabaseTemplateGenerator.cs
--------------------------------------------------
using System;
using System.IO;
using System.Data.OleDb;
using System.Threading.Tasks;
using System.Text;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Classe utilitaire pour générer des bases de données template Access
    /// </summary>
    public static class DatabaseTemplateGenerator
    {
        /// <summary>
        /// Crée une base de données template avec la structure définie dans la configuration
        /// </summary>
        /// <param name="templatePath">Chemin complet où la base de données template sera créée</param>
        /// <param name="config">Configuration définissant la structure de la base de données</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateDatabaseTemplateAsync(string templatePath, DatabaseConfiguration config)
        {
            try
            {
                // S'assurer que le répertoire existe
                string directory = Path.GetDirectoryName(templatePath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                // Supprimer le fichier s'il existe déjà
                if (File.Exists(templatePath))
                {
                    File.Delete(templatePath);
                }

                // Créer une nouvelle base de données Access vide
                LogManager.Info($"Création d'une nouvelle base de données Access à {templatePath}");
                
                try
                {
                    // Stratégie 1: Utiliser une base de données template vide existante (méthode préférée)
                    string emptyTemplateFile = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "EmptyTemplate.accdb");
                    if (File.Exists(emptyTemplateFile))
                    {
                        // Copier le modèle vide vers la destination
                        LogManager.Info("Utilisation d'un modèle vide existant");
                        File.Copy(emptyTemplateFile, templatePath, true);
                        goto CreateTables;
                    }
                    
                    // Stratégie 2: Utiliser ADOX pour créer une nouvelle base de données (meilleure approche)
                    LogManager.Info("Tentative de création via ADOX");
                    
                    try
                    {
                        // ADOX est une bibliothèque COM qui permet de créer des objets ADO et des bases de données
                        // Nous utilisons la réflexion pour éviter une dépendance directe au moment de la compilation
                        Type catalogType = Type.GetTypeFromProgID("ADOX.Catalog");
                        if (catalogType != null)
                        {
                            LogManager.Info("ADOX est disponible, création de la base de données...");
                            
                            // Créer une instance du catalogue
                            dynamic catalog = Activator.CreateInstance(catalogType);
                            
                            // Définir la chaîne de connexion et créer la base de données
                            string connectionString2 = $"Provider=Microsoft.ACE.OLEDB.16.0;Data Source={templatePath};";
                            catalog.Create(connectionString2);
                            
                            LogManager.Info($"Base de données créée avec succès via ADOX à {templatePath}");
                            goto CreateTables;
                        }
                        else
                        {
                            LogManager.Warning("ADOX n'est pas disponible sur ce système");
                        }
                    }
                    catch (Exception adoxEx)
                    {
                        LogManager.Warning($"Erreur lors de la création via ADOX: {adoxEx.Message}");
                    }
                    
                    // Stratégie 3: Créer une base avec une approche native OleDb
                    LogManager.Info("Création d'une base de données vide via OleDb");
                    string dbConnectionString = $"Provider=Microsoft.ACE.OLEDB.16.0;Data Source={templatePath};Jet OLEDB:Engine Type=5;";
                    
                    // Créer un répertoire temporaire pour travailler si nécessaire
                    string tempDir = Path.Combine(Path.GetTempPath(), Path.GetRandomFileName());
                    Directory.CreateDirectory(tempDir);
                    
                    try
                    {
                        // Script SQL pour créer une table système minimale
                        string minimalTableSql = "CREATE TABLE MinimalTable (ID COUNTER PRIMARY KEY, Name TEXT(255))";
                        
                        // Créer un fichier vide
                        using (var fs = File.Create(templatePath))
                        {
                            fs.Close();
                        }
                        
                        // Essayer d'ouvrir une connexion et créer une table minimale
                        using (var connection = new OleDbConnection(dbConnectionString))
                        {
                            try
                            {
                                connection.Open();
                                using (var command = new OleDbCommand(minimalTableSql, connection))
                                {
                                    command.ExecuteNonQuery();
                                }
                                connection.Close();
                                LogManager.Info("Base de données Access créée avec succès via OleDb");
                            }
                            catch (Exception ex)
                            {
                                LogManager.Warning($"Échec de la création via OleDb: {ex.Message}");
                                // Continuer avec la stratégie 3
                            }
                        }
                    }
                    finally
                    {
                        // Nettoyer le répertoire temporaire
                        try { Directory.Delete(tempDir, true); } catch { }
                    }
                    
                    // Stratégie 3: Informer clairement de l'échec et des alternatives
                    LogManager.Error("Toutes les stratégies de création ont échoué",
                    new InvalidOperationException(
                        "Impossible de créer une base de données Access valide. \n" +
                        "Veuillez créer manuellement une base Access vide et la placer dans le répertoire de l'application " +
                        "sous le nom 'EmptyTemplate.accdb', ou installer Microsoft Access Database Engine."));
                }
                catch (Exception ex)
                {
                    LogManager.Error($"Erreur lors de la création de la base de données : {ex.Message}", ex);
                    return false;
                }

                CreateTables:
                // Ouvrir une connexion pour créer les tables
                string connectionString = $"Provider=Microsoft.ACE.OLEDB.16.0;Data Source={templatePath};Persist Security Info=False;";
                using (var connection = new OleDbConnection(connectionString))
                {
                    await connection.OpenAsync();
                    
                    // Créer les tables définies dans la configuration
                    foreach (var table in config.Tables)
                    {
                        try
                        {
                            LogManager.Info($"Création de la table {table.Name}...");
                            using (var command = new OleDbCommand(table.CreateTableSql, connection))
                            {
                                await command.ExecuteNonQueryAsync();
                            }
                            LogManager.Info($"Table {table.Name} créée avec succès");
                        }
                        catch (Exception ex)
                        {
                            LogManager.Error($"Erreur lors de la création de la table {table.Name} : {ex.Message}", new Exception(""));
                        }
                    }
                }

                return true;
            }
            catch (Exception ex)
            {
                LogManager.Error($"Erreur lors de la création de la base de données template : {ex.Message}", ex);
                return false;
            }
        }

        /// <summary>
        /// Crée une base de données template avec une structure standard
        /// </summary>
        /// <param name="templatePath">Chemin complet où la base de données template sera créée</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateStandardTemplateAsync(string templatePath)
        {
            // Créer une configuration standard
            var config = DatabaseConfiguration.CreateDefault(Path.GetDirectoryName(templatePath));
            
            return await CreateDatabaseTemplateAsync(templatePath, config);
        }

        /// <summary>
        /// Crée une base de données template avec une structure personnalisée
        /// </summary>
        /// <param name="templatePath">Chemin complet où la base de données template sera créée</param>
        /// <param name="configureAction">Action permettant de configurer la structure de la base de données</param>
        /// <returns>True si la création a réussi, False sinon</returns>
        public static async Task<bool> CreateCustomTemplateAsync(string templatePath, Action<DatabaseConfiguration> configureAction)
        {
            // Créer une configuration de base
            var config = DatabaseConfiguration.CreateDefault(Path.GetDirectoryName(templatePath));
            
            // Appliquer la configuration personnalisée
            configureAction?.Invoke(config);
            
            return await CreateDatabaseTemplateAsync(templatePath, config);
        }

        /// <summary>
        /// Vérifie si la structure d'une base de données existante correspond à la configuration
        /// </summary>
        /// <param name="databasePath">Chemin de la base de données à vérifier</param>
        /// <param name="config">Configuration définissant la structure attendue</param>
        /// <returns>True si la structure correspond, False sinon</returns>
        public static async Task<bool> ValidateDatabaseStructureAsync(string databasePath, DatabaseConfiguration config)
        {
            if (!File.Exists(databasePath))
                return false;

            try
            {
                string connectionString = $"Provider=Microsoft.ACE.OLEDB.16.0;Data Source={databasePath};Persist Security Info=False;";
                using (var connection = new OleDbConnection(connectionString))
                {
                    await connection.OpenAsync();
                    
                    // Vérifier chaque table définie dans la configuration
                    foreach (var table in config.Tables)
                    {
                        // Vérifier si la table existe
                        bool tableExists = false;
                        using (var command = new OleDbCommand(
                            "SELECT COUNT(*) FROM MSysObjects WHERE Type=1 AND Name=?", connection))
                        {
                            command.Parameters.AddWithValue("@Name", table.Name);
                            int count = Convert.ToInt32(await command.ExecuteScalarAsync());
                            tableExists = count > 0;
                        }

                        if (!tableExists)
                            return false;

                        // Vérifier les colonnes de la table
                        foreach (var column in table.Columns)
                        {
                            bool columnExists = false;
                            using (var command = new OleDbCommand(
                                "SELECT COUNT(*) FROM MSysObjects o " +
                                "INNER JOIN MSysColumns c ON o.Id = c.TableId " +
                                "WHERE o.Name=? AND c.Name=?", connection))
                            {
                                command.Parameters.AddWithValue("@TableName", table.Name);
                                command.Parameters.AddWithValue("@ColumnName", column.Name);
                                int count = Convert.ToInt32(await command.ExecuteScalarAsync());
                                columnExists = count > 0;
                            }

                            if (!columnExists)
                                return false;
                        }
                    }
                }

                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Met à jour la structure d'une base de données existante pour correspondre à la configuration
        /// </summary>
        /// <param name="databasePath">Chemin de la base de données à mettre à jour</param>
        /// <param name="config">Configuration définissant la structure attendue</param>
        /// <returns>True si la mise à jour a réussi, False sinon</returns>
        public static async Task<bool> UpdateDatabaseStructureAsync(string databasePath, DatabaseConfiguration config)
        {
            if (!File.Exists(databasePath))
                return false;

            try
            {
                string connectionString = $"Provider=Microsoft.ACE.OLEDB.16.0;Data Source={databasePath};Persist Security Info=False;";
                using (var connection = new OleDbConnection(connectionString))
                {
                    await connection.OpenAsync();
                    
                    // Vérifier et mettre à jour chaque table définie dans la configuration
                    foreach (var table in config.Tables)
                    {
                        // Vérifier si la table existe
                        bool tableExists = false;
                        using (var command = new OleDbCommand(
                            "SELECT COUNT(*) FROM MSysObjects WHERE Type=1 AND Name=?", connection))
                        {
                            command.Parameters.AddWithValue("@Name", table.Name);
                            int count = Convert.ToInt32(await command.ExecuteScalarAsync());
                            tableExists = count > 0;
                        }

                        if (!tableExists)
                        {
                            // Créer la table si elle n'existe pas
                            using (var command = new OleDbCommand(table.CreateTableSql, connection))
                            {
                                await command.ExecuteNonQueryAsync();
                            }
                        }
                        else
                        {
                            // Vérifier et ajouter les colonnes manquantes
                            foreach (var column in table.Columns)
                            {
                                bool columnExists = false;
                                using (var command = new OleDbCommand(
                                    "SELECT COUNT(*) FROM MSysObjects o " +
                                    "INNER JOIN MSysColumns c ON o.Id = c.TableId " +
                                    "WHERE o.Name=? AND c.Name=?", connection))
                                {
                                    command.Parameters.AddWithValue("@TableName", table.Name);
                                    command.Parameters.AddWithValue("@ColumnName", column.Name);
                                    int count = Convert.ToInt32(await command.ExecuteScalarAsync());
                                    columnExists = count > 0;
                                }

                                if (!columnExists)
                                {
                                    // Ajouter la colonne manquante
                                    string nullableText = column.IsNullable ? "" : " NOT NULL";
                                    string alterSql = $"ALTER TABLE {table.Name} ADD COLUMN {column.Name} {column.SqlType}{nullableText}";
                                    
                                    using (var command = new OleDbCommand(alterSql, connection))
                                    {
                                        await command.ExecuteNonQueryAsync();
                                    }
                                }
                            }
                        }
                    }
                }

                return true;
            }
            catch (Exception ex)
            {
                LogManager.Error($"Erreur lors de la mise à jour de la structure de la base de données : {ex.Message}", ex);
                return false;
            }
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\EntityConverter.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.OleDb;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Convertisseur entre les entités et les enregistrements de base de données
    /// </summary>
    public static class EntityConverter
    {
        /// <summary>
        /// Convertit un DataReader en entité
        /// </summary>
        public static Entity ConvertToEntity(IDataReader reader, TableConfiguration tableConfig)
        {
            var entity = new Entity
            {
                TableName = tableConfig.Name,
                PrimaryKeyColumn = tableConfig.PrimaryKeyColumn,
                LastModifiedColumn = tableConfig.LastModifiedColumn,
                VersionColumn = tableConfig.VersionColumn
            };

            // Lire toutes les colonnes du reader
            for (int i = 0; i < reader.FieldCount; i++)
            {
                string columnName = reader.GetName(i);
                object value = reader[i];

                // Convertir DBNull en null
                if (value == DBNull.Value)
                {
                    value = null;
                }

                entity.Properties[columnName] = value;
            }

            return entity;
        }

        /// <summary>
        /// Ajoute les paramètres d'une entité à une commande OleDb
        /// </summary>
        public static void AddParametersFromEntity(OleDbCommand command, Entity entity, TableConfiguration tableConfig, bool includePrimaryKey = true)
        {
            foreach (var column in tableConfig.Columns)
            {
                // Exclure la clé primaire si demandé
                if (!includePrimaryKey && column.Name == tableConfig.PrimaryKeyColumn)
                    continue;

                object value = DBNull.Value;

                if (entity.Properties.ContainsKey(column.Name))
                {
                    value = entity.Properties[column.Name] ?? DBNull.Value;

                    // Gérer les conversions de types spécifiques
                    if (value != DBNull.Value)
                    {
                        // S'assurer que les dates sont dans un format acceptable
                        if (value is DateTime dateValue)
                        {
                            value = dateValue.ToOADate();
                        }
                        else if (value is bool boolValue)
                        {
                            value = boolValue ? 1 : 0;
                        }
                    }
                }
                else
                {
                    if (value is bool boolValue)
                    {
                        value = 0;
                    }
                    else if (value is DateTime dateValue)
                    {
                        value = DateTime.MinValue.ToOADate();
                    }

                }

                command.Parameters.AddWithValue($"@{column.Name}", value);
            }
        }

        /// <summary>
        /// Obtient les valeurs des colonnes d'une entité dans l'ordre défini par la configuration
        /// </summary>
        public static object[] GetColumnValuesFromEntity(Entity entity, TableConfiguration tableConfig)
        {
            var values = new object[tableConfig.Columns.Count];

            for (int i = 0; i < tableConfig.Columns.Count; i++)
            {
                var column = tableConfig.Columns[i];

                if (entity.Properties.ContainsKey(column.Name))
                {
                    values[i] = entity.Properties[column.Name];
                }
                else
                {
                    values[i] = DBNull.Value;
                }
            }

            return values;
        }

        /// <summary>
        /// Crée une copie profonde d'une entité
        /// </summary>
        public static Entity CloneEntity(Entity source)
        {
            var clone = new Entity
            {
                TableName = source.TableName,
                PrimaryKeyColumn = source.PrimaryKeyColumn,
                LastModifiedColumn = source.LastModifiedColumn,
                VersionColumn = source.VersionColumn
            };

            foreach (var kvp in source.Properties)
            {
                // Cloner les valeurs pour éviter les références partagées
                if (kvp.Value is ICloneable cloneable)
                {
                    clone.Properties[kvp.Key] = cloneable.Clone();
                }
                else
                {
                    clone.Properties[kvp.Key] = kvp.Value;
                }
            }

            return clone;
        }

        /// <summary>
        /// Compare deux entités pour détecter les différences
        /// </summary>
        public static Dictionary<string, (object oldValue, object newValue)> CompareEntities(Entity entity1, Entity entity2)
        {
            var differences = new Dictionary<string, (object, object)>();

            // Vérifier toutes les propriétés de entity1
            foreach (var prop in entity1.Properties)
            {
                if (!entity2.Properties.ContainsKey(prop.Key))
                {
                    differences[prop.Key] = (prop.Value, null);
                }
                else if (!AreValuesEqual(prop.Value, entity2.Properties[prop.Key]))
                {
                    differences[prop.Key] = (prop.Value, entity2.Properties[prop.Key]);
                }
            }

            // Vérifier les propriétés qui existent uniquement dans entity2
            foreach (var prop in entity2.Properties)
            {
                if (!entity1.Properties.ContainsKey(prop.Key))
                {
                    differences[prop.Key] = (null, prop.Value);
                }
            }

            return differences;
        }

        /// <summary>
        /// Compare deux valeurs pour l'égalité
        /// </summary>
        private static bool AreValuesEqual(object value1, object value2)
        {
            // Si les deux sont null, ils sont égaux
            if (value1 == null && value2 == null)
                return true;

            // Si un seul est null, ils ne sont pas égaux
            if (value1 == null || value2 == null)
                return false;

            // Comparaison spéciale pour les dates (ignorer les millisecondes)
            if (value1 is DateTime date1 && value2 is DateTime date2)
            {
                return Math.Abs((date1 - date2).TotalSeconds) < 1;
            }

            // Comparaison spéciale pour les nombres décimaux
            if (IsNumericType(value1) && IsNumericType(value2))
            {
                double d1 = Convert.ToDouble(value1);
                double d2 = Convert.ToDouble(value2);
                return Math.Abs(d1 - d2) < 0.0001;
            }

            // Comparaison standard
            return value1.Equals(value2);
        }

        /// <summary>
        /// Vérifie si un type est numérique
        /// </summary>
        private static bool IsNumericType(object o)
        {
            return o is byte || o is sbyte ||
                   o is short || o is ushort ||
                   o is int || o is uint ||
                   o is long || o is ulong ||
                   o is float || o is double ||
                   o is decimal;
        }
    }
}

====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\LogManager.cs
--------------------------------------------------
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Gestionnaire de logs centralisé avec support asynchrone
    /// </summary>
    public static class LogManager
    {
        private static string _logDirectory;
        private static int _retentionDays;
        private static readonly ConcurrentQueue<LogEntry> _logQueue = new ConcurrentQueue<LogEntry>();
        private static readonly SemaphoreSlim _logSemaphore = new SemaphoreSlim(1, 1);
        private static Timer _flushTimer;
        private static bool _isInitialized = false;

        /// <summary>
        /// Initialise le gestionnaire de logs
        /// </summary>
        public static void Initialize(string logDirectory, int retentionDays = 30)
        {
            if (_isInitialized)
                return;

            _logDirectory = logDirectory;
            _retentionDays = retentionDays;

            // Créer le répertoire s'il n'existe pas
            if (!Directory.Exists(_logDirectory))
            {
                Directory.CreateDirectory(_logDirectory);
            }

            // Démarrer le timer pour vider la queue régulièrement
            _flushTimer = new Timer(async _ => await FlushLogsAsync(), null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));

            _isInitialized = true;
        }

        /// <summary>
        /// Enregistre un message d'information
        /// </summary>
        public static void Info(string message)
        {
            Log(LogLevel.Info, message, null);
        }

        /// <summary>
        /// Enregistre un message de debug
        /// </summary>
        public static void Debug(string message)
        {
            Log(LogLevel.Debug, message, null);
        }

        /// <summary>
        /// Enregistre un message d'avertissement
        /// </summary>
        public static void Warning(string message, Exception ex = null)
        {
            Log(LogLevel.Warning, message, ex);
        }

        /// <summary>
        /// Enregistre un message d'erreur
        /// </summary>
        public static void Error(string message, Exception ex)
        {
            Log(LogLevel.Error, message, ex);
        }

        /// <summary>
        /// Enregistre un message dans la queue
        /// </summary>
        private static void Log(LogLevel level, string message, Exception exception)
        {
            if (!_isInitialized)
            {
                // Si non initialisé, écrire dans la console
                Console.WriteLine($"[{level}] {message}");
                if (exception != null)
                    Console.WriteLine(exception.ToString());
                return;
            }

            var entry = new LogEntry
            {
                Timestamp = DateTime.Now,
                Level = level,
                Message = message,
                Exception = exception,
                ThreadId = Thread.CurrentThread.ManagedThreadId
            };

            _logQueue.Enqueue(entry);

            // Si c'est une erreur, forcer l'écriture immédiate
            if (level == LogLevel.Error)
            {
                Task.Run(async () => await FlushLogsAsync());
            }
        }

        /// <summary>
        /// Vide la queue de logs dans le fichier
        /// </summary>
        private static async Task FlushLogsAsync()
        {
            if (_logQueue.IsEmpty)
                return;

            await _logSemaphore.WaitAsync();
            try
            {
                string logFile = Path.Combine(_logDirectory, $"OfflineFirstAccess_{DateTime.Now:yyyyMMdd}.log");

                using (var writer = new StreamWriter(logFile, append: true))
                {
                    while (_logQueue.TryDequeue(out var entry))
                    {
                        string logLine = FormatLogEntry(entry);
                        await writer.WriteLineAsync(logLine);

                        // Écrire aussi dans la console en mode debug
#if DEBUG
                        Console.WriteLine(logLine);
#endif
                    }
                }

                // Nettoyer les vieux logs (garder seulement 30 jours)
                CleanupOldLogs();
            }
            catch (Exception ex)
            {
                // En cas d'erreur, écrire dans la console
                Console.WriteLine($"Erreur lors de l'écriture des logs : {ex.Message}");
            }
            finally
            {
                _logSemaphore.Release();
            }
        }

        /// <summary>
        /// Formate une entrée de log
        /// </summary>
        private static string FormatLogEntry(LogEntry entry)
        {
            string baseMessage = $"{entry.Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{entry.Level,-7}] [Thread:{entry.ThreadId:D3}] {entry.Message}";

            if (entry.Exception != null)
            {
                baseMessage += Environment.NewLine + "Exception: " + entry.Exception.ToString();
            }

            return baseMessage;
        }

        /// <summary>
        /// Nettoie les anciens fichiers de log
        /// </summary>
        private static void CleanupOldLogs()
        {
            try
            {
                var cutoffDate = DateTime.Now.AddDays(-30);
                var files = Directory.GetFiles(_logDirectory, "OfflineFirstAccess_*.log");

                foreach (var file in files)
                {
                    var fileInfo = new FileInfo(file);
                    if (fileInfo.CreationTime < cutoffDate)
                    {
                        File.Delete(file);
                    }
                }
            }
            catch
            {
                // Ignorer les erreurs de nettoyage
            }
        }

        /// <summary>
        /// Arrête le gestionnaire de logs
        /// </summary>
        public static async Task ShutdownAsync()
        {
            if (!_isInitialized)
                return;

            _flushTimer?.Dispose();
            await FlushLogsAsync();
            _isInitialized = false;
        }

        /// <summary>
        /// Niveau de log
        /// </summary>
        private enum LogLevel
        {
            Debug,
            Info,
            Warning,
            Error
        }

        /// <summary>
        /// Entrée de log
        /// </summary>
        private class LogEntry
        {
            public DateTime Timestamp { get; set; }
            public LogLevel Level { get; set; }
            public string Message { get; set; }
            public Exception Exception { get; set; }
            public int ThreadId { get; set; }
        }
    }
}

====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Helpers\RetryHelper.cs
--------------------------------------------------
using System;
using System.Threading.Tasks;
using OfflineFirstAccess.Helpers;

namespace OfflineFirstAccess.Helpers
{
    /// <summary>
    /// Helper pour gérer les retry avec backoff exponentiel
    /// </summary>
    public static class RetryHelper
    {
        private static readonly Random _random = new Random();

        /// <summary>
        /// Exécute une opération avec retry automatique en cas d'échec
        /// </summary>
        public static async Task<T> ExecuteWithRetryAsync<T>(
            Func<Task<T>> operation,
            int maxRetries = 3,
            int baseDelayMs = 1000,
            Func<Exception, bool> shouldRetry = null)
        {
            int retryCount = 0;
            Exception lastException = null;

            while (retryCount <= maxRetries)
            {
                try
                {
                    return await operation();
                }
                catch (Exception ex)
                {
                    lastException = ex;

                    // Vérifier si on doit réessayer
                    if (shouldRetry != null && !shouldRetry(ex))
                    {
                        throw;
                    }

                    // Si on a atteint le nombre max de tentatives, abandonner
                    if (retryCount >= maxRetries)
                    {
                        LogManager.Error($"Échec après {maxRetries} tentatives", ex);
                        throw;
                    }

                    // Calculer le délai avec backoff exponentiel
                    var backoff = TimeSpan.FromMilliseconds(baseDelayMs * (int)Math.Pow(2, retryCount));
                    var jitter = TimeSpan.FromMilliseconds(_random.Next(0, 100)); // Jitter to prevent thundering herd
                    var delay = backoff + jitter;

                    LogManager.Warning($"Tentative {retryCount + 1}/{maxRetries} échouée, nouvelle tentative dans {delay.TotalMilliseconds}ms", ex);

                    await Task.Delay(delay, cancellationToken);
                    retryCount++;
                }
            }

            throw lastException ?? new InvalidOperationException("Échec de l'opération");
        }

        /// <summary>
        /// Version pour les opérations sans valeur de retour
        /// </summary>
        public static async Task ExecuteWithRetryAsync(
            Func<Task> operation,
            int maxRetries = 3,
            int baseDelayMs = 1000,
            Func<Exception, bool> shouldRetry = null)
        {
            await ExecuteWithRetryAsync(async () =>
            {
                await operation();
                return true;
            }, maxRetries, baseDelayMs, shouldRetry);
        }

        /// <summary>
        /// Détermine si une exception est récupérable
        /// </summary>
        public static bool IsRetriableException(Exception ex)
        {
            // Timeout
            if (ex is TimeoutException)
                return true;

            // Erreurs réseau
            if (ex.Message.Contains("network") ||
                ex.Message.Contains("connection") ||
                ex.Message.Contains("timeout"))
                return true;

            // Erreurs de base de données spécifiques
            if (ex is System.Data.OleDb.OleDbException oleDbEx)
            {
                // Codes d'erreur récupérables
                var retriableCodes = new[] {
                    -2147467259, // Timeout
                    -2147217843, // Deadlock
                    -2147217900  // Connection broken
                };

                foreach (var code in retriableCodes)
                {
                    if (oleDbEx.ErrorCode == code)
                        return true;
                }
            }

            return false;
        }
    }
}

====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\ChangeLogEntry.cs
--------------------------------------------------
using System;

namespace OfflineFirstAccess.Models
{
    public class ChangeLogEntry
    {
        public long Id { get; set; }
        public string TableName { get; set; }
        public string RowGuid { get; set; }
        public string OperationType { get; set; } // e.g., "INSERT", "UPDATE", "DELETE"
        public DateTime TimestampUTC { get; set; }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\ConfigParameter.cs
--------------------------------------------------
using System;

namespace OfflineFirstAccess.Models
{
    /// <summary>
    /// Représente un paramètre de configuration stocké en base de données
    /// </summary>
    public class ConfigParameter
    {
        /// <summary>
        /// Clé unique du paramètre
        /// </summary>
        public string Key { get; set; }
        
        /// <summary>
        /// Valeur du paramètre
        /// </summary>
        public string Value { get; set; }
        
        /// <summary>
        /// Description du paramètre
        /// </summary>
        public string Description { get; set; }
        
        /// <summary>
        /// Catégorie du paramètre
        /// </summary>
        public string Category { get; set; }
        
        /// <summary>
        /// Date de dernière modification
        /// </summary>
        public DateTime LastModified { get; set; }
        
        /// <summary>
        /// Indique si le paramètre est modifiable par l'utilisateur
        /// </summary>
        public bool IsUserEditable { get; set; }
        
        /// <summary>
        /// Constructeur par défaut
        /// </summary>
        public ConfigParameter()
        {
            LastModified = DateTime.Now;
            IsUserEditable = true;
        }
        
        /// <summary>
        /// Constructeur avec paramètres essentiels
        /// </summary>
        public ConfigParameter(string key, string value, string description = "", string category = "General")
        {
            Key = key;
            Value = value;
            Description = description;
            Category = category;
            LastModified = DateTime.Now;
            IsUserEditable = true;
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\Conflict.cs
--------------------------------------------------
using GenericRecord = System.Collections.Generic.Dictionary<string, object>;

namespace OfflineFirstAccess.Models
{
    public class Conflict
    {
        public string TableName { get; set; }
        public string RowGuid { get; set; }
        public GenericRecord LocalVersion { get; set; }
        public GenericRecord RemoteVersion { get; set; }
        public string ConflictType { get; set; } // e.g., "Update-Update", "Update-Delete"
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\DatabaseConfiguration.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;

namespace OfflineFirstAccess.Models
{
    /// <summary>
    /// Configuration globale pour le système de base de données offline-first
    /// </summary>
    public class DatabaseConfiguration
    {
        /// <summary>
        /// Nom du modèle de fichier pour les bases de données locales
        /// </summary>
        public string LocalDatabasePath { get; set; } = "Local_{0}.accdb";
        
        /// <summary>
        /// Chemin d'accès au dossier de stockage des bases de données locales
        /// </summary>
        public string LocalStoragePath { get; set; }
        
        /// <summary>
        /// Nom du modèle de fichier pour les bases de données distantes (données)
        /// </summary>
        public string RemoteDataDatabasePath { get; set; } = "\\\\serveur\\share\\Data_{0}.accdb";
        
        /// <summary>
        /// Nom du modèle de fichier pour les bases de données distantes (verrous)
        /// </summary>
        public string RemoteLockDatabasePath { get; set; } = "\\\\serveur\\share\\Lock_{0}.accdb";
        
        /// <summary>
        /// Nom du modèle de fichier pour les signaux de session
        /// </summary>
        public string RemoteSignalFilePath { get; set; } = "\\\\serveur\\share\\Sessions_{0}.signal";
        
        /// <summary>
        /// Intervalle en secondes pour la vérification des modifications
        /// </summary>
        public int ChangeCheckIntervalSeconds { get; set; } = 60;
        
        /// <summary>
        /// Nombre maximum de tentatives de connexion
        /// </summary>
        public int MaxConnectionRetries { get; set; } = 3;
        
        /// <summary>
        /// Délai en millisecondes entre les tentatives de connexion
        /// </summary>
        public int ConnectionRetryDelayMs { get; set; } = 1000;
        
        /// <summary>
        /// Liste des configurations de tables
        /// </summary>
        public List<TableConfiguration> Tables { get; set; } = new List<TableConfiguration>();
        
        /// <summary>
        /// Obtient le chemin d'accès à la base de données locale pour l'identifiant spécifié
        /// </summary>
        public string GetLocalDatabasePath(string identifier)
        {
            return Path.Combine(LocalStoragePath, string.Format(LocalDatabasePath, identifier));
        }
        
        /// <summary>
        /// Obtient le chemin d'accès à la base de données distante (données) pour l'identifiant spécifié
        /// </summary>
        public string GetRemoteDataDatabasePath(string identifier)
        {
            return string.Format(RemoteDataDatabasePath, identifier);
        }
        
        /// <summary>
        /// Obtient le chemin d'accès à la base de données distante (verrous) pour l'identifiant spécifié
        /// </summary>
        public string GetRemoteLockDatabasePath(string identifier)
        {
            return string.Format(RemoteLockDatabasePath, identifier);
        }
        
        /// <summary>
        /// Obtient le chemin d'accès au fichier de signal pour l'identifiant spécifié
        /// </summary>
        public string GetRemoteSignalFilePath(string identifier)
        {
            return string.Format(RemoteSignalFilePath, identifier);
        }
        
        /// <summary>
        /// Obtient la configuration d'une table par son nom
        /// </summary>
        public TableConfiguration GetTableConfiguration(string tableName)
        {
            return Tables.Find(t => t.Name == tableName);
        }
        
        /// <summary>
        /// Crée une configuration standard avec des tables prédéfinies
        /// </summary>
        public static DatabaseConfiguration CreateDefault(string localStoragePath)
        {
            var config = new DatabaseConfiguration
            {
                LocalStoragePath = localStoragePath
            };
            
            // CORRECTION : ChangeLog supprimé de la config locale car maintenant dans la base Lock
            // ChangeLog est géré automatiquement par EnsureChangeLogTableExistsAsync dans GenericAccessService.Lock.cs
            
            // Ajouter la table des verrous (SyncLocks)
            var syncLocksTable = new TableConfiguration
            {
                Name = "SyncLocks",
                PrimaryKeyColumn = "LockID",
                PrimaryKeyType = typeof(string),
                LastModifiedColumn = "CreatedAt",
                CreateTableSql = @"CREATE TABLE SyncLocks (
                    LockID TEXT(255) PRIMARY KEY,
                    Reason TEXT(255) NOT NULL,
                    CreatedAt DATETIME NOT NULL,
                    ExpiresAt DATETIME,
                    MachineName TEXT(100),
                    ProcessId LONG
                )"
            };
            
            syncLocksTable.Columns.Add(new ColumnDefinition("LockID", typeof(string), "TEXT(255)", false, true));
            syncLocksTable.Columns.Add(new ColumnDefinition("Reason", typeof(string), "TEXT(255)", false));
            syncLocksTable.Columns.Add(new ColumnDefinition("CreatedAt", typeof(DateTime), "DATETIME", false));
            syncLocksTable.Columns.Add(new ColumnDefinition("ExpiresAt", typeof(DateTime), "DATETIME", true));
            syncLocksTable.Columns.Add(new ColumnDefinition("MachineName", typeof(string), "TEXT(100)", true));
            syncLocksTable.Columns.Add(new ColumnDefinition("ProcessId", typeof(long), "LONG", true));
            
            // Ajouter la table des sessions (Sessions)
            var sessionsTable = new TableConfiguration
            {
                Name = "Sessions",
                PrimaryKeyColumn = "SessionID",
                PrimaryKeyType = typeof(string),
                LastModifiedColumn = "LastActivity",
                CreateTableSql = @"CREATE TABLE Sessions (
                    SessionID TEXT(255) PRIMARY KEY,
                    UserID TEXT(50) NOT NULL,
                    MachineName TEXT(50) NOT NULL,
                    StartTime DATETIME NOT NULL,
                    LastActivity DATETIME NOT NULL,
                    IsActive BIT NOT NULL
                )"
            };
            
            sessionsTable.Columns.Add(new ColumnDefinition("SessionID", typeof(string), "TEXT(255)", false, true));
            sessionsTable.Columns.Add(new ColumnDefinition("UserID", typeof(string), "TEXT(50)", false));
            sessionsTable.Columns.Add(new ColumnDefinition("MachineName", typeof(string), "TEXT(50)", false));
            sessionsTable.Columns.Add(new ColumnDefinition("StartTime", typeof(DateTime), "DATETIME", false));
            sessionsTable.Columns.Add(new ColumnDefinition("LastActivity", typeof(DateTime), "DATETIME", false));
            sessionsTable.Columns.Add(new ColumnDefinition("IsActive", typeof(bool), "BIT", false));
            
            // Ajouter la table des paramètres de configuration (T_ConfigParameters)
            var configParamsTable = new TableConfiguration
            {
                Name = "T_ConfigParameters",
                PrimaryKeyColumn = "Key",
                PrimaryKeyType = typeof(string),
                LastModifiedColumn = "LastModified",
                VersionColumn = "Version",
                CreateTableSql = @"CREATE TABLE T_ConfigParameters (
                    [Key] TEXT(255) PRIMARY KEY,
                    Value TEXT(255) NOT NULL,
                    Description TEXT(255),
                    Category TEXT(50) NOT NULL,
                    LastModified DATETIME NOT NULL,
                    Version LONG DEFAULT 1,
                    IsUserEditable BIT DEFAULT 1
                )"
            };
            
            configParamsTable.Columns.Add(new ColumnDefinition("Key", typeof(string), "TEXT(255)", false, true));
            configParamsTable.Columns.Add(new ColumnDefinition("Value", typeof(string), "TEXT(255)", false));
            configParamsTable.Columns.Add(new ColumnDefinition("Description", typeof(string), "TEXT(255)", true));
            configParamsTable.Columns.Add(new ColumnDefinition("Category", typeof(string), "TEXT(50)", false));
            configParamsTable.Columns.Add(new ColumnDefinition("LastModified", typeof(DateTime), "DATETIME", false));
            configParamsTable.Columns.Add(new ColumnDefinition("Version", typeof(long), "LONG", false));
            configParamsTable.Columns.Add(new ColumnDefinition("IsUserEditable", typeof(bool), "BIT", false));

            // Ajouter la table des données Ambre (T_Data_Ambre)
            var dataAmbreTable = new TableConfiguration
            {
                Name = "T_Data_Ambre",
                PrimaryKeyColumn = "ID",
                PrimaryKeyType = typeof(string),
                LastModifiedColumn = "LastModified",
                DeleteDateColumn = "DeleteDate",
                VersionColumn = "Version",
                CreateTableSql = @"CREATE TABLE T_Data_Ambre (
        ID                           TEXT(255)    PRIMARY KEY,  
        Account_ID                   TEXT(50),                  
        CCY                          TEXT(3),                   
        Country                      TEXT(255),                   
        Event_Num                    TEXT(50),                  
        Folder                       TEXT(255),                 
        Pivot_MbawIDFromLabel        TEXT(255),                 
        Pivot_TransactionCodesFromLabel TEXT(255),              
        Pivot_TRNFromLabel           TEXT(255),                 
        RawLabel                     TEXT(255),                 
        Receivable_DWRefFromAmbre    TEXT(255),                 
        LocalSignedAmount            DOUBLE,      
        Operation_Date               DATETIME,                  
        Reconciliation_Num           TEXT(255),                 
        Receivable_InvoiceFromAmbre  TEXT(255),                 
        ReconciliationOrigin_Num     TEXT(255),                 
        SignedAmount                 DOUBLE,      
        Value_Date                   DATETIME,                  
        -- Champs BaseEntity
        CreationDate                 DATETIME,                  
        DeleteDate                   DATETIME,                  
        ModifiedBy                   TEXT(100),                 
        LastModified                 DATETIME,                  
        Version                      LONG     
    )"
            };

            // -- Colonnes métier T_Data_Ambre
            dataAmbreTable.Columns.Add(new ColumnDefinition("ID", typeof(string), "TEXT(255)", true, true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Account_ID", typeof(string), "TEXT(50)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("CCY", typeof(string), "TEXT(3)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Country", typeof(string), "TEXT(3)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Event_Num", typeof(string), "TEXT(50)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Folder", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Pivot_MbawIDFromLabel", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Pivot_TransactionCodesFromLabel", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Pivot_TRNFromLabel", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("RawLabel", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Receivable_DWRefFromAmbre", typeof(string), "TEXT(255)", true));

            dataAmbreTable.Columns.Add(new ColumnDefinition("LocalSignedAmount", typeof(double), "DOUBLE", false));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Operation_Date", typeof(DateTime), "DATETIME", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Reconciliation_Num", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Receivable_InvoiceFromAmbre", typeof(string), "TEXT(255)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("ReconciliationOrigin_Num", typeof(string), "TEXT(255)", true));

            dataAmbreTable.Columns.Add(new ColumnDefinition("SignedAmount", typeof(double), "DOUBLE", false));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Value_Date", typeof(DateTime), "DATETIME", true));

            // -- Champs BaseEntity
            dataAmbreTable.Columns.Add(new ColumnDefinition("CreationDate", typeof(DateTime), "DATETIME", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("DeleteDate", typeof(DateTime), "DATETIME", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("ModifiedBy", typeof(string), "TEXT(100)", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("LastModified", typeof(DateTime), "DATETIME", true));
            dataAmbreTable.Columns.Add(new ColumnDefinition("Version", typeof(long), "LONG", false));


            // Ajouter la table de réconciliation (T_Reconciliation)
            var reconciliationTable = new TableConfiguration
            {
                Name = "T_Reconciliation",
                PrimaryKeyColumn = "ID",
                PrimaryKeyType = typeof(string),
                LastModifiedColumn = "LastModified",
                DeleteDateColumn = "DeleteDate",
                VersionColumn = "Version",
                CreateTableSql = @"CREATE TABLE T_Reconciliation (
                            ID                     TEXT(255)  PRIMARY KEY,
                            DWINGS_GuaranteeID     TEXT(255),
                            DWINGS_InvoiceID       TEXT(255),
                            DWINGS_CommissionID    TEXT(255),
                            Action                 BIT,               
                            Comments               TEXT(255),
                            InternalInvoiceReference TEXT(255),
                            FirstClaimDate         DATETIME,
                            LastClaimDate          DATETIME,
                            ToRemind               BIT,      
                            ToRemindDate           DATETIME,
                            ACK                    BIT,      
                            SwiftCode              TEXT(50),
                            PaymentReference       TEXT(255),
                            KPI                    LONG,     
                            IncidentType           LONG,     
                            RiskyItem              LONG,
                            ReasonNonRisky         TEXT(255),
                            CreationDate           DATETIME,
                            DeleteDate             DATETIME,
                            ModifiedBy             TEXT(100),
                            LastModified           DATETIME,
                            Version                LONG  DEFAULT 1
                        )"
            };

            /* ---------- Définition des colonnes ---------- */
            // Champs métier
            reconciliationTable.Columns.Add(new ColumnDefinition("ID", typeof(string), "TEXT(255)", false, true));
            reconciliationTable.Columns.Add(new ColumnDefinition("DWINGS_GuaranteeID", typeof(string), "TEXT(255)", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("DWINGS_InvoiceID", typeof(string), "TEXT(255)", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("DWINGS_CommissionID", typeof(string), "TEXT(255)", true));

            reconciliationTable.Columns.Add(new ColumnDefinition("Action", typeof(bool), "BIT", false));
            reconciliationTable.Columns.Add(new ColumnDefinition("Comments", typeof(string), "TEXT(255)", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("InternalInvoiceReference", typeof(string), "TEXT(255)", true));

            reconciliationTable.Columns.Add(new ColumnDefinition("FirstClaimDate", typeof(DateTime), "DATETIME", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("LastClaimDate", typeof(DateTime), "DATETIME", true));

            reconciliationTable.Columns.Add(new ColumnDefinition("ToRemind", typeof(bool), "BIT", false));
            reconciliationTable.Columns.Add(new ColumnDefinition("ToRemindDate", typeof(DateTime), "DATETIME", true));

            reconciliationTable.Columns.Add(new ColumnDefinition("ACK", typeof(bool), "BIT", false));
            reconciliationTable.Columns.Add(new ColumnDefinition("SwiftCode", typeof(string), "TEXT(50)", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("PaymentReference", typeof(string), "TEXT(255)", true));

            reconciliationTable.Columns.Add(new ColumnDefinition("KPI", typeof(int), "LONG", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("IncidentType", typeof(int), "LONG", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("RiskyItem", typeof(int), "LONG", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("ReasonNonRisky", typeof(string), "TEXT(255)", true));

            // Champs BaseEntity
            reconciliationTable.Columns.Add(new ColumnDefinition("CreationDate", typeof(DateTime), "DATETIME", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("DeleteDate", typeof(DateTime), "DATETIME", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("ModifiedBy", typeof(string), "TEXT(100)", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("LastModified", typeof(DateTime), "DATETIME", true));
            reconciliationTable.Columns.Add(new ColumnDefinition("Version", typeof(long), "LONG", false));


            // CORRECTION : ChangeLog supprimé - maintenant dans la base Lock
            config.Tables.Add(syncLocksTable);
            config.Tables.Add(sessionsTable);
            config.Tables.Add(configParamsTable);
            config.Tables.Add(dataAmbreTable);
            config.Tables.Add(reconciliationTable);

            return config;
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\Entity.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.Dynamic;

namespace OfflineFirstAccess.Models
{
    /// <summary>
    /// Classe générique pour représenter n'importe quelle entité dans le système
    /// </summary>
    public class Entity
    {
        /// <summary>
        /// Nom de la table à laquelle cette entité appartient
        /// </summary>
        public string TableName { get; set; }
        
        /// <summary>
        /// Colonne utilisée comme identifiant primaire
        /// </summary>
        public string PrimaryKeyColumn { get; set; }

        /// <summary>
        /// Colonne utilisée pour le timestamp de modification
        /// </summary>
        public string LastModifiedColumn { get; set; } = "LastModified";

        /// <summary>
        /// Colonne utilisée pour le numéro de version
        /// </summary>
        public string VersionColumn { get; set; } = "Version";
        
        /// <summary>
        /// Dictionnaire des propriétés de l'entité
        /// Les clés correspondent aux noms de colonnes
        /// </summary>
        public Dictionary<string, object> Properties { get; set; } = new Dictionary<string, object>();
        
        /// <summary>
        /// Obtient ou définit une propriété de l'entité
        /// </summary>
        /// <param name="name">Nom de la propriété (colonne)</param>
        public object this[string name]
        {
            get => Properties.ContainsKey(name) ? Properties[name] : null;
            set => Properties[name] = value;
        }
        
        /// <summary>
        /// Obtient la valeur de l'identifiant primaire
        /// </summary>
        public object GetPrimaryKey()
        {
            return Properties.ContainsKey(PrimaryKeyColumn) ? Properties[PrimaryKeyColumn] : null;
        }
        
        /// <summary>
        /// Obtient la date de dernière modification
        /// </summary>
        public DateTime GetLastModified()
        {
            if (Properties.ContainsKey(LastModifiedColumn) && Properties[LastModifiedColumn] is DateTime date)
            {
                return date;
            }
            return DateTime.MinValue;
        }
        
        /// <summary>
        /// Obtient le numéro de version de l'entité
        /// </summary>
        /// <returns>Le numéro de version ou 0 si non défini</returns>
        public long GetVersion()
        {
            if (Properties.ContainsKey(VersionColumn))
            {
                if (Properties[VersionColumn] is long longVersion)
                    return longVersion;
                    
                if (Properties[VersionColumn] is int intVersion)
                    return intVersion;
                    
                if (Properties[VersionColumn] != null)
                {
                    // Tenter de convertir d'autres types en long
                    try
                    {
                        return Convert.ToInt64(Properties[VersionColumn]);
                    }
                    catch
                    {
                        // Ignorer les erreurs de conversion
                    }
                }
            }
            return 0;
        }
        
        /// <summary>
        /// Incrémente et définit le numéro de version de l'entité
        /// </summary>
        /// <returns>Le nouveau numéro de version</returns>
        public long IncrementVersion()
        {
            long currentVersion = GetVersion();
            long newVersion = currentVersion + 1;
            Properties[VersionColumn] = newVersion;
            return newVersion;
        }
        
        /// <summary>
        /// Met à jour la date de modification et le numéro de version
        /// </summary>
        public void UpdateVersionAndTimestamp()
        {
            // Mettre à jour la date de dernière modification
            Properties[LastModifiedColumn] = DateTime.Now;
            
            // Incrémenter le numéro de version
            IncrementVersion();
        }
        
        /// <summary>
        /// Définit la valeur du timestamp de dernière modification
        /// </summary>
        public void SetLastModified(DateTime value)
        {
            Properties[LastModifiedColumn] = value;
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\SyncConfiguration.cs
--------------------------------------------------
using System.Collections.Generic;

namespace OfflineFirstAccess.Models
{
    /// <summary>
    /// Data object to define the synchronization behavior.
    /// </summary>
    public class SyncConfiguration
    {
        public string LocalDatabasePath { get; set; }
        public string RemoteDatabasePath { get; set; }
        public List<string> TablesToSync { get; set; } = new List<string>();

        // Standard metadata columns
        public string LastModifiedColumn { get; set; } = "LastModifiedUTC";
        public string IsDeletedColumn { get; set; } = "IsDeleted";
        public string PrimaryKeyGuidColumn { get; set; } = "RowGuid";
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\SyncResult.cs
--------------------------------------------------
using System;

namespace OfflineFirstAccess.Models
{
    /// <summary>
    /// Résultat d'une opération de synchronisation avec informations de diagnostic
    /// </summary>
    public class SyncResult
    {
        /// <summary>
        /// Constructeur par défaut
        /// </summary>
        public SyncResult()
        {
            StartTime = DateTime.Now;
        }

        /// <summary>
        /// Indique si la synchronisation a réussi
        /// </summary>
        public bool Success { get; set; }

        /// <summary>
        /// Message d'information ou d'erreur
        /// </summary>
        public string Message { get; set; }

        /// <summary>
        /// Détails complémentaires en cas d'erreur
        /// </summary>
        public string ErrorDetails { get; set; }

        /// <summary>
        /// Exception capturée lors de la synchronisation
        /// </summary>
        public Exception Exception { get; set; }

        /// <summary>
        /// Nombre de conflits résolus
        /// </summary>
        public int ConflictsResolved { get; set; }

        /// <summary>
        /// Nombre d'entités envoyées vers le serveur
        /// </summary>
        public int PushedChanges { get; set; }

        /// <summary>
        /// Nombre d'entités récupérées du serveur
        /// </summary>
        public int PulledChanges { get; set; }

        /// <summary>
        /// Liste des conflits non résolus à la fin de la synchronisation.
        /// </summary>
        public List<Conflict> UnresolvedConflicts { get; set; } = new List<Conflict>();

        /// <summary>
        /// Date et heure de la synchronisation
        /// </summary>
        public DateTime SyncTime { get; set; } = DateTime.Now;

        /// <summary>
        /// Durée totale de la synchronisation en millisecondes
        /// </summary>
        public long SyncTimeMs { get; set; }

        /// <summary>
        /// Heure de début de la synchronisation
        /// </summary>
        public DateTime StartTime { get; private set; }

        /// <summary>
        /// Heure de fin de la synchronisation
        /// </summary>
        public DateTime EndTime
        {
            get
            {
                if (SyncTimeMs > 0)
                    return StartTime.AddMilliseconds(SyncTimeMs);
                return DateTime.Now;
            }
        }

        /// <summary>
        /// Nombre total d'entités traitées (envoyées + reçues)
        /// </summary>
        public int TotalEntitiesProcessed => PushedChanges + PulledChanges;

        /// <summary>
        /// Taux de traitement moyen des entités (entités par seconde)
        /// </summary>
        public double EntitiesPerSecond
        {
            get
            {
                if (SyncTimeMs <= 0) return 0;
                return TotalEntitiesProcessed / (SyncTimeMs / 1000.0);
            }
        }
    }

    /// <summary>
    /// Représente un conflit de synchronisation
    /// </summary>
    public class SyncConflict
    {
        /// <summary>
        /// Nom de la table concernée
        /// </summary>
        public string TableName { get; set; }
        
        /// <summary>
        /// ID de l'enregistrement en conflit
        /// </summary>
        public string RecordId { get; set; }
        
        /// <summary>
        /// Type de conflit
        /// </summary>
        public string ConflictType { get; set; }
        
        /// <summary>
        /// Description du conflit
        /// </summary>
        public string Description { get; set; }
        
        /// <summary>
        /// Indique si le conflit a été résolu
        /// </summary>
        public bool IsResolved { get; set; }
        
        /// <summary>
        /// Stratégie utilisée pour résoudre le conflit
        /// </summary>
        public string ResolutionStrategy { get; set; }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Models\TableConfiguration.cs
--------------------------------------------------
using System;
using System.Collections.Generic;

namespace OfflineFirstAccess.Models
{
    /// <summary>
    /// Configuration d'une table dans le système offline-first
    /// </summary>
    public class TableConfiguration
    {
        /// <summary>
        /// Nom de la table
        /// </summary>
        public string Name { get; set; }
        
        /// <summary>
        /// Nom de la colonne utilisée comme clé primaire
        /// </summary>
        public string PrimaryKeyColumn { get; set; }
        
        /// <summary>
        /// Type de la clé primaire
        /// </summary>
        public Type PrimaryKeyType { get; set; }
        
        /// <summary>
        /// Nom de la colonne qui stocke la date de dernière modification
        /// </summary>
        public string LastModifiedColumn { get; set; } = "LastModified";
        
        /// <summary>
        /// Nom de la colonne qui stocke le numéro de version de l'entité
        /// </summary>
        public string VersionColumn { get; set; } = "Version";
        
        /// <summary>
        /// Liste des colonnes de la table
        /// </summary>
        public List<ColumnDefinition> Columns { get; set; } = new List<ColumnDefinition>();
        
        /// <summary>
        /// Script SQL pour créer la table
        /// </summary>
        public string CreateTableSql { get; set; }
        
        /// <summary>
        /// Requête SQL pour sélectionner toutes les entités
        /// </summary>
        public string SelectAllSql => $"SELECT * FROM {Name}";
        
        /// <summary>
        /// Requête SQL pour sélectionner une entité par sa clé primaire
        /// </summary>
        public string SelectByIdSql => $"SELECT * FROM {Name} WHERE {PrimaryKeyColumn} = ?";
        
        /// <summary>
        /// Requête SQL pour sélectionner les entités modifiées depuis une certaine date
        /// </summary>
        public string SelectChangedSinceSql => $"SELECT * FROM {Name} WHERE {LastModifiedColumn} > ?";
        
        /// <summary>
        /// Génère la requête SQL d'insertion
        /// </summary>
        public string GenerateInsertSql()
        {
            var columnNames = new List<string>();
            var paramPlaceholders = new List<string>();
            
            foreach (var column in Columns)
            {
                columnNames.Add("[" + column.Name + "]");
                paramPlaceholders.Add("?");
            }
            
            return $"INSERT INTO {Name} ({string.Join(", ", columnNames)}) VALUES ({string.Join(", ", paramPlaceholders)})";
        }
        
        /// <summary>
        /// Génère la requête SQL de mise à jour
        /// </summary>
        public string GenerateUpdateSql()
        {
            var setStatements = new List<string>();
            
            foreach (var column in Columns)
            {
                if (column.Name != PrimaryKeyColumn) // Ne pas mettre à jour la clé primaire
                {
                    setStatements.Add($"{column.Name} = ?");
                }
            }
            
            return $"UPDATE {Name} SET {string.Join(", ", setStatements)} WHERE {PrimaryKeyColumn} = ?";
        }
        
        /// <summary>
        /// Requête SQL pour supprimer une entité
        /// </summary>
        public string DeleteSql => $"DELETE FROM {Name} WHERE {PrimaryKeyColumn} = ?";

        public string DeleteDateColumn { get; internal set; } = "DeleteDate";
    }
    
    /// <summary>
    /// Définition d'une colonne dans une table
    /// </summary>
    public class ColumnDefinition
    {
        /// <summary>
        /// Nom de la colonne
        /// </summary>
        public string Name { get; set; }
        
        /// <summary>
        /// Type de données de la colonne
        /// </summary>
        public Type DataType { get; set; }
        
        /// <summary>
        /// Type de données SQL (ex: INTEGER, TEXT, etc.)
        /// </summary>
        public string SqlType { get; set; }
        
        /// <summary>
        /// Indique si la colonne peut être nulle
        /// </summary>
        public bool IsNullable { get; set; } = true;
        
        /// <summary>
        /// Indique si la colonne est une clé primaire
        /// </summary>
        public bool IsPrimaryKey { get; set; } = false;
        
        /// <summary>
        /// Indique si la colonne est auto-incrémentée
        /// </summary>
        public bool IsAutoIncrement { get; set; } = false;
        
        /// <summary>
        /// Constructeur
        /// </summary>
        public ColumnDefinition(string name, Type dataType, string sqlType, bool isNullable = true, bool isPrimaryKey = false, bool isAutoIncrement = false)
        {
            Name = name;
            DataType = dataType;
            SqlType = sqlType;
            IsNullable = isNullable;
            IsPrimaryKey = isPrimaryKey;
            IsAutoIncrement = isAutoIncrement;
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\obj\Debug\.NETFramework,Version=v4.8.AssemblyAttributes.cs
--------------------------------------------------
// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETFramework,Version=v4.8", FrameworkDisplayName = ".NET Framework 4.8")]


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Properties\AssemblyInfo.cs
--------------------------------------------------
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// Les informations générales relatives à un assembly dépendent de
// l'ensemble d'attributs suivant. Changez les valeurs de ces attributs pour modifier les informations
// associées à un assembly.
[assembly: AssemblyTitle("OfflineFirstAccess")]
[assembly: AssemblyDescription("Bibliothèque pour l'accès aux données en mode offline-first avec Microsoft Access")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("OfflineFirstAccess")]
[assembly: AssemblyCopyright("Copyright © 2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// L'affectation de la valeur false à ComVisible rend les types invisibles dans cet assembly
// aux composants COM. Si vous devez accéder à un type dans cet assembly à partir de
// COM, affectez la valeur true à l'attribut ComVisible sur ce type.
[assembly: ComVisible(false)]

// Le GUID suivant est pour l'ID de la typelib si ce projet est exposé à COM
[assembly: Guid("c8d2f3c9-6f64-4ab5-a3c2-61e854e7f5cd")]

// Les informations de version pour un assembly se composent des quatre valeurs suivantes :
//
//      Version principale
//      Version secondaire
//      Numéro de build
//      Révision
//
// Vous pouvez spécifier toutes les valeurs ou indiquer les numéros de build et de révision par défaut
// en utilisant '*', comme indiqué ci-dessous :
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Services\ConfigParameterService.cs
--------------------------------------------------
using System;
using System.Collections.Generic;
using System.Data.OleDb;
using System.Threading.Tasks;
using OfflineFirstAccess.Helpers;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Services
{
    /// <summary>
    /// Service de gestion des paramètres de configuration stockés en base de données
    /// </summary>
    public class T_ConfigParameterservice
    {
        private readonly string _connectionString;
        private readonly string _contextIdentifier;
        private readonly Dictionary<string, ConfigParameter> _parameterCache;
        
        /// <summary>
        /// Constructeur
        /// </summary>
        /// <param name="connectionString">Chaîne de connexion à la base de données</param>
        /// <param name="contextIdentifier">Identifiant de contexte</param>
        public T_ConfigParameterservice(string connectionString, string contextIdentifier)
        {
            _connectionString = connectionString ?? throw new ArgumentNullException(nameof(connectionString));
            _contextIdentifier = contextIdentifier ?? throw new ArgumentNullException(nameof(contextIdentifier));
            _parameterCache = new Dictionary<string, ConfigParameter>();
        }
        
        /// <summary>
        /// Initialise le service et charge les paramètres en cache
        /// </summary>
        public async Task InitializeAsync()
        {
            await LoadParametersAsync();
        }
        
        /// <summary>
        /// Charge tous les paramètres de configuration depuis la base de données
        /// </summary>
        public async Task LoadParametersAsync()
        {
            _parameterCache.Clear();
            
            try
            {
                using (var connection = new OleDbConnection(_connectionString))
                {
                    await connection.OpenAsync();
                    
                    string sql = "SELECT * FROM T_ConfigParameters";
                    using (var command = new OleDbCommand(sql, connection))
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        while (await reader.ReadAsync())
                        {
                            var parameter = new ConfigParameter
                            {
                                Key = reader["CPA_Key"].ToString(),
                                Value = reader["CPA_Value"]?.ToString(),
                                Description = reader["CPA_Description"]?.ToString(),
                                Category = reader["CPA_Category"]?.ToString(),
                                LastModified = reader["CPA_LastModified"] != DBNull.Value
                                    ? Convert.ToDateTime(reader["CPA_LastModified"])
                                    : DateTime.Now,
                                IsUserEditable = reader["CPA_IsUserEditable"] != DBNull.Value
                                    ? Convert.ToBoolean(reader["CPA_IsUserEditable"])
                                    : true
                            };
                            
                            _parameterCache[parameter.Key] = parameter;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                LogManager.Error($"Erreur lors du chargement des paramètres : {ex.Message}", ex);
            }
        }
        
        /// <summary>
        /// Obtient un paramètre par sa clé
        /// </summary>
        /// <param name="key">Clé du paramètre</param>
        /// <param name="defaultValue">Valeur par défaut si le paramètre n'existe pas</param>
        /// <returns>Valeur du paramètre ou valeur par défaut</returns>
        public string GetParameterValue(string key, string defaultValue = null)
        {
            if (_parameterCache.TryGetValue(key, out var parameter))
            {
                return parameter.Value;
            }
            
            return defaultValue;
        }
        
        /// <summary>
        /// Obtient un paramètre typé par sa clé
        /// </summary>
        /// <typeparam name="T">Type de la valeur</typeparam>
        /// <param name="key">Clé du paramètre</param>
        /// <param name="defaultValue">Valeur par défaut si le paramètre n'existe pas</param>
        /// <returns>Valeur du paramètre convertie au type spécifié ou valeur par défaut</returns>
        public T GetParameterValue<T>(string key, T defaultValue = default)
        {
            if (_parameterCache.TryGetValue(key, out var parameter))
            {
                try
                {
                    if (typeof(T) == typeof(int))
                    {
                        return (T)(object)Convert.ToInt32(parameter.Value);
                    }
                    else if (typeof(T) == typeof(long))
                    {
                        return (T)(object)Convert.ToInt64(parameter.Value);
                    }
                    else if (typeof(T) == typeof(double))
                    {
                        return (T)(object)Convert.ToDouble(parameter.Value);
                    }
                    else if (typeof(T) == typeof(bool))
                    {
                        return (T)(object)Convert.ToBoolean(parameter.Value);
                    }
                    else if (typeof(T) == typeof(DateTime))
                    {
                        return (T)(object)Convert.ToDateTime(parameter.Value);
                    }
                    else
                    {
                        return (T)Convert.ChangeType(parameter.Value, typeof(T));
                    }
                }
                catch
                {
                    return defaultValue;
                }
            }
            
            return defaultValue;
        }
        
        /// <summary>
        /// Définit la valeur d'un paramètre
        /// </summary>
        /// <param name="key">Clé du paramètre</param>
        /// <param name="value">Nouvelle valeur</param>
        /// <param name="description">Description (optionnelle)</param>
        /// <param name="category">Catégorie (optionnelle)</param>
        /// <param name="isUserEditable">Indique si le paramètre est modifiable par l'utilisateur</param>
        /// <returns>True si l'opération a réussi</returns>
        public async Task<bool> SetParameterValueAsync(string key, string value, string description = null, string category = null, bool isUserEditable = true)
        {
            if (string.IsNullOrEmpty(key))
                throw new ArgumentException("La clé du paramètre ne peut pas être nulle ou vide", nameof(key));
            
            // Sauvegarde du paramètre existant pour le rollback en cas d'échec
            ConfigParameter oldParameter = null;
            if (_parameterCache.TryGetValue(key, out var existingParam))
            {
                // Faire une copie profonde pour pouvoir restaurer
                oldParameter = new ConfigParameter
                {
                    Key = existingParam.Key,
                    Value = existingParam.Value,
                    Description = existingParam.Description,
                    Category = existingParam.Category,
                    LastModified = existingParam.LastModified,
                    IsUserEditable = existingParam.IsUserEditable
                };
            }
            
            try
            {
                // Créer ou mettre à jour le paramètre en cache
                var parameter = existingParam ?? new ConfigParameter { Key = key };
                
                parameter.Value = value;
                parameter.LastModified = DateTime.Now;
                
                if (description != null)
                    parameter.Description = description;
                
                if (category != null)
                    parameter.Category = category;
                
                parameter.IsUserEditable = isUserEditable;
                
                // Mettre à jour temporairement le cache - on le validera après la mise à jour en base
                _parameterCache[key] = parameter;
                
                // Enregistrer en base de données
                using (var connection = new OleDbConnection(_connectionString))
                {
                    await connection.OpenAsync();
                    
                    // Utiliser une transaction pour assurer l'atomicité
                    using (var transaction = connection.BeginTransaction())
                    {
                        try
                        {
                            // Vérifier si le paramètre existe déjà
                            bool exists = false;
                            using (var command = new OleDbCommand("SELECT COUNT(*) FROM T_ConfigParameters WHERE [Key] = ?", connection, transaction))
                            {
                                command.Parameters.AddWithValue("@Key", key);
                                exists = Convert.ToInt32(await command.ExecuteScalarAsync()) > 0;
                            }
                            
                            if (exists)
                            {
                                // Mise à jour
                                using (var command = new OleDbCommand(
                                    "UPDATE T_ConfigParameters SET [CPA_Value] = ?, [CPA_Description] = ?, [CPA_Category] = ?, " +
                                    "[CPA_LastModified] = ?, [CPA_IsUserEditable] = ? WHERE [CPA_Key] = ?", connection, transaction))
                                {
                                    command.Parameters.AddWithValue("@Value", value ?? (object)DBNull.Value);
                                    command.Parameters.AddWithValue("@Description", parameter.Description ?? (object)DBNull.Value);
                                    command.Parameters.AddWithValue("@Category", parameter.Category ?? (object)DBNull.Value);
                                    command.Parameters.AddWithValue("@LastModified", parameter.LastModified);
                                    command.Parameters.AddWithValue("@IsUserEditable", parameter.IsUserEditable);
                                    command.Parameters.AddWithValue("@Key", key);
                                    
                                    await command.ExecuteNonQueryAsync();
                                }
                            }
                            else
                            {
                                // Insertion
                                using (var command = new OleDbCommand(
                                    "INSERT INTO T_ConfigParameters ([CPA_Key], [CPA_Value], [CPA_Description], [CPA_Category], [CPA_LastModified], [CPA_IsUserEditable]) " +
                                    "VALUES (?, ?, ?, ?, ?, ?)", connection, transaction))
                                {
                                    command.Parameters.AddWithValue("@Key", key);
                                    command.Parameters.AddWithValue("@Value", value ?? (object)DBNull.Value);
                                    command.Parameters.AddWithValue("@Description", parameter.Description ?? (object)DBNull.Value);
                                    command.Parameters.AddWithValue("@Category", parameter.Category ?? (object)DBNull.Value);
                                    command.Parameters.AddWithValue("@LastModified", parameter.LastModified);
                                    command.Parameters.AddWithValue("@IsUserEditable", parameter.IsUserEditable);
                                    
                                    await command.ExecuteNonQueryAsync();
                                }
                            }
                            
                            // Valider la transaction
                            transaction.Commit();
                            return true;
                        }
                        catch (Exception ex)
                        {
                            // Annuler la transaction
                            LogManager.Error($"Erreur lors de l'enregistrement du paramètre en base : {ex.Message}", ex);
                            transaction.Rollback();
                            throw; // Propager l'exception pour déclencher le rollback du cache
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                // Rollback du cache en cas d'erreur
                if (oldParameter != null)
                {
                    // Restaurer l'ancienne valeur dans le cache
                    _parameterCache[key] = oldParameter;
                    LogManager.Info($"Rollback du cache pour le paramètre {key} après échec de la mise à jour en base");
                }
                else
                {
                    // Supprimer l'entrée du cache si elle n'existait pas avant
                    _parameterCache.Remove(key);
                    LogManager.Info($"Suppression du paramètre {key} du cache après échec de l'insertion en base");
                }
                
                LogManager.Error($"Erreur lors de la mise à jour du paramètre : {ex.Message}", ex);
                return false;
            }
        }
        
        /// <summary>
        /// Supprime un paramètre
        /// </summary>
        /// <param name="key">Clé du paramètre à supprimer</param>
        /// <returns>True si l'opération a réussi</returns>
        public async Task<bool> DeleteParameterAsync(string key)
        {
            if (string.IsNullOrEmpty(key))
                throw new ArgumentException("La clé du paramètre ne peut pas être vide", nameof(key));
            
            // Sauvegarde du paramètre existant pour le rollback en cas d'échec
            ConfigParameter oldParameter = null;
            bool existsInCache = _parameterCache.TryGetValue(key, out var existingParam);
            
            if (existsInCache)
            {
                // Faire une copie profonde pour pouvoir restaurer
                oldParameter = new ConfigParameter
                {
                    Key = existingParam.Key,
                    Value = existingParam.Value,
                    Description = existingParam.Description,
                    Category = existingParam.Category,
                    LastModified = existingParam.LastModified,
                    IsUserEditable = existingParam.IsUserEditable
                };
            }
            else
            {
                // Le paramètre n'est pas dans le cache, rien à supprimer
                return false;
            }
            
            try
            {
                // Supprimer du cache (temporairement)
                _parameterCache.Remove(key);
                
                using (var connection = new OleDbConnection(_connectionString))
                {
                    await connection.OpenAsync();
                    
                    // Utiliser une transaction pour assurer l'atomicité
                    using (var transaction = connection.BeginTransaction())
                    {
                        try
                        {
                            string sql = "DELETE FROM T_ConfigParameters WHERE [CPA_Key] = @Key";
                            using (var command = new OleDbCommand(sql, connection, transaction))
                            {
                                command.Parameters.AddWithValue("@Key", key);
                                
                                int rowsAffected = await command.ExecuteNonQueryAsync();
                                if (rowsAffected > 0)
                                {
                                    // Valider la transaction si au moins une ligne a été affectée
                                    transaction.Commit();
                                    return true;
                                }
                                else
                                {
                                    // Annuler la transaction si aucune ligne n'a été affectée
                                    LogManager.Warning($"Le paramètre {key} n'a pas été trouvé en base lors de la tentative de suppression");
                                    transaction.Rollback();
                                    throw new Exception($"Le paramètre {key} n'existe pas en base de données");
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // Annuler la transaction
                            LogManager.Error($"Erreur lors de la suppression du paramètre en base : {ex.Message}", ex);
                            transaction.Rollback();
                            throw; // Propager l'exception pour déclencher le rollback du cache
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                // Rollback du cache en cas d'erreur
                if (oldParameter != null)
                {
                    // Restaurer l'ancienne valeur dans le cache
                    _parameterCache[key] = oldParameter;
                    LogManager.Info($"Rollback du cache pour le paramètre {key} après échec de la suppression en base");
                }
                
                LogManager.Error($"Erreur lors de la suppression du paramètre : {ex.Message}", ex);
                return false;
            }
        }
        
        /// <summary>
        /// Obtient tous les paramètres
        /// </summary>
        /// <returns>Liste des paramètres</returns>
        public List<ConfigParameter> GetAllParameters()
        {
            var result = new List<ConfigParameter>();
            
            foreach (var parameter in _parameterCache.Values)
            {
                result.Add(parameter);
            }
            
            return result;
        }
        
        /// <summary>
        /// Obtient tous les paramètres d'une catégorie
        /// </summary>
        /// <param name="category">Catégorie</param>
        /// <returns>Liste des paramètres de la catégorie</returns>
        public List<ConfigParameter> GetParametersByCategory(string category)
        {
            if (string.IsNullOrEmpty(category))
                throw new ArgumentException("La catégorie ne peut pas être vide", nameof(category));
                
            var result = new List<ConfigParameter>();
            
            foreach (var parameter in _parameterCache.Values)
            {
                if (parameter.Category == category)
                {
                    result.Add(parameter);
                }
            }
            
            return result;
        }
        
        /// <summary>
        /// Initialise les paramètres par défaut
        /// </summary>
        /// <returns>True si l'opération a réussi</returns>
        public async Task<bool> InitializeDefaultParametersAsync()
        {
            try
            {
                // Paramètres de chemins
                await SetParameterValueAsync("LocalDatabaseFormat", "Local_{0}.accdb", 
                    "Format du nom de fichier pour les bases de données locales", "Paths", false);
                    
                await SetParameterValueAsync("RemoteDataDatabaseFormat", "\\\\serveur\\share\\Data_{0}.accdb", 
                    "Format du chemin pour les bases de données distantes (données)", "Paths", false);
                    
                await SetParameterValueAsync("RemoteLockDatabaseFormat", "\\\\serveur\\share\\Lock_{0}.accdb", 
                    "Format du chemin pour les bases de données distantes (verrous)", "Paths", false);
                    
                await SetParameterValueAsync("RemoteSignalFileFormat", "\\\\serveur\\share\\Sessions_{0}.signal", 
                    "Format du chemin pour les fichiers de signal", "Paths", false);
                
                // Paramètres de connexion et de synchronisation
                await SetParameterValueAsync("ConnectionTimeoutSeconds", "30", 
                    "Délai d'expiration des connexions à la base de données en secondes", "Connection", true);
                    
                await SetParameterValueAsync("MaxConnectionRetries", "3", 
                    "Nombre maximum de tentatives de connexion", "Connection", true);
                    
                await SetParameterValueAsync("ConnectionRetryDelayMs", "500", 
                    "Délai entre les tentatives de connexion en millisecondes", "Connection", true);
                    
                await SetParameterValueAsync("ChangeCheckIntervalSeconds", "60", 
                    "Intervalle de vérification des changements en secondes", "Sync", true);
                    
                await SetParameterValueAsync("SyncLockTimeoutSeconds", "30", 
                    "Délai d'expiration des verrous de synchronisation en secondes", "Sync", true);
                    
                // Paramètres de session
                await SetParameterValueAsync("SessionTimeoutMinutes", "5", 
                    "Délai d'expiration des sessions en minutes", "Session", true);
                    
                await SetParameterValueAsync("HeartbeatIntervalMinutes", "1", 
                    "Intervalle d'envoi des signaux de heartbeat en minutes", "Session", true);
                    
                await SetParameterValueAsync("FallbackCheckIntervalSeconds", "30", 
                    "Intervalle de vérification de secours en secondes", "Session", true);
                    
                await SetParameterValueAsync("TimestampToleranceSeconds", "5", 
                    "Tolérance pour les comparaisons d'horodatages en secondes", "Sync", true);
                    
                await SetParameterValueAsync("SyncConflictStrategy", "LastModifiedWins", 
                    "Stratégie de résolution des conflits de synchronisation", "Sync", true);
                    
                // Note: HeartbeatIntervalMinutes est déjà défini plus haut, nous n'avons pas besoin de HeartbeatIntervalSeconds
                // pour éviter la confusion avec deux paramètres similaires
                
                // Ajouter des paramètres pour les batchs de synchronisation (recommandé par l'analyse)
                await SetParameterValueAsync("ConflictDetectionBatchSize", "5",
                    "Taille des lots pour la détection des conflits", "Sync", true);
                    
                await SetParameterValueAsync("SyncUpdateBatchSize", "50",
                    "Taille des lots pour les mises à jour pendant la synchronisation", "Sync", true);
                
                return true;
            }
            catch (Exception ex)
            {
                LogManager.Error($"Erreur lors de l'initialisation des paramètres par défaut : {ex.Message}", ex);
                return false;
            }
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Synchronization\ISynchronizationService.cs
--------------------------------------------------
using System;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Synchronization
{
    /// <summary>
    /// The public interface for the synchronization service.
    /// </summary>
    public interface ISynchronizationService
    {
        /// <summary>
        /// Initializes the service with a specific configuration.
        /// </summary>
        /// <param name="config">The synchronization configuration.</param>
        Task InitializeAsync(SyncConfiguration config);

        /// <summary>
        /// Runs a full synchronization process.
        /// </summary>
        /// <param name="onProgress">An optional callback to report progress.</param>
        /// <returns>A SyncResult object summarizing the operation.</returns>
        Task<SyncResult> SynchronizeAsync(Action<int, string> onProgress = null);
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Synchronization\SynchronizationService.cs
--------------------------------------------------
using System;
using System.Threading.Tasks;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Synchronization
{
    public class SynchronizationService : ISynchronizationService
    {
        private SyncConfiguration _config;
        private SyncOrchestrator _orchestrator;

        public Task InitializeAsync(SyncConfiguration config)
        {
            _config = config;

            // 1. Create Data Providers for local and remote databases
            var localProvider = new Data.AccessDataProvider(config.LocalDatabasePath, config);
            var remoteProvider = new Data.AccessDataProvider(config.RemoteDatabasePath, config);

            // 2. Create the Change Tracker for the local database
            var changeTracker = new ChangeTracking.ChangeTracker(config.LocalDatabasePath);

            // 3. Create the Conflict Resolver
            var conflictResolver = new ManualConflictResolver(config);

            // 4. Assemble the Orchestrator
            _orchestrator = new SyncOrchestrator(localProvider, remoteProvider, changeTracker, conflictResolver, _config);
            
            return Task.CompletedTask;
        }

        public Task<SyncResult> SynchronizeAsync(Action<int, string> onProgress = null)
        {
            if (_orchestrator == null)
            {
                throw new InvalidOperationException("Service must be initialized with a valid configuration before synchronization.");
            }

            // Delegate the work to the orchestrator
            return _orchestrator.SynchronizeAsync(onProgress);
        }
    }
}


====================================================================================================

Chemin: C:\Users\gianni\RT v2\OfflineFirstAccess\Synchronization\SyncOrchestrator.cs
--------------------------------------------------
using System;
using System.Linq;
using System.Threading.Tasks;
using OfflineFirstAccess.Data;
using OfflineFirstAccess.ChangeTracking;
using OfflineFirstAccess.Conflicts;
using OfflineFirstAccess.Models;

namespace OfflineFirstAccess.Synchronization
{
    /// <summary>
    /// The internal engine that performs the synchronization logic.
    /// </summary>
    public class SyncOrchestrator
    {
        private readonly IDataProvider _localProvider;
        private readonly IDataProvider _remoteProvider;
        private readonly IChangeTracker _changeTracker;
        private readonly IConflictResolver _conflictResolver;
        private readonly SyncConfiguration _config;
        

        public SyncOrchestrator(
            IDataProvider localProvider, 
            IDataProvider remoteProvider, 
            IChangeTracker changeTracker, 
            IConflictResolver conflictResolver,
            SyncConfiguration config)
        {
            _localProvider = localProvider;
            _remoteProvider = remoteProvider;
            _changeTracker = changeTracker;
            _conflictResolver = conflictResolver;
            _config = config;
        }

        public async Task<SyncResult> SynchronizeAsync(Action<int, string> onProgress)
        {
            var syncStartTime = DateTime.UtcNow;
            var allUnresolvedConflicts = new System.Collections.Generic.List<Conflict>();

            try
            {
                // --- PHASE 1: PUSH (Client -> Server) ---
                onProgress?.Invoke(10, "Getting local changes to push...");
                var allLocalChanges = await _changeTracker.GetUnsyncedChangesAsync();
                var changesByTable = allLocalChanges.GroupBy(c => c.TableName);

                foreach (var tableGroup in changesByTable)
                {
                    var tableName = tableGroup.Key;
                    onProgress?.Invoke(20, $"Pushing changes for table {tableName}...");
                    var recordsToPush = await _localProvider.GetRecordsByGuid(tableName, tableGroup.Select(c => c.RowGuid));
                    await _remoteProvider.ApplyChangesAsync(tableName, recordsToPush);
                    await _changeTracker.MarkChangesAsSyncedAsync(tableGroup.Select(c => c.Id));
                }

                // --- PHASE 2: PULL (Server -> Client) ---
                onProgress?.Invoke(50, "Pulling remote changes...");
                var lastSyncTimestamp = await GetLastSyncTimestampAsync();

                foreach (var tableName in _config.TablesToSync)
                {
                    onProgress?.Invoke(60, $"Pulling changes for table {tableName}...");
                    var remoteChanges = await _remoteProvider.GetChangesAsync(tableName, lastSyncTimestamp);

                    if (remoteChanges.Any())
                    {
                        var localChangesForTable = allLocalChanges.Where(c => c.TableName == tableName).ToList();
                        var localGuids = new HashSet<string>(localChangesForTable.Select(c => c.RowGuid));

                        var cleanRemoteChanges = remoteChanges.Where(r => !localGuids.Contains(r.RowGuid)).ToList();
                        var potentialConflictRemoteChanges = remoteChanges.Where(r => localGuids.Contains(r.RowGuid)).ToList();

                        var (conflicts, nonConflictsFromDetection) = _conflictResolver.DetectConflicts(potentialConflictRemoteChanges, localChangesForTable);
                        allUnresolvedConflicts.AddRange(conflicts);
                        var resolvedChanges = _conflictResolver.ResolveConflicts(conflicts);

                        var changesToApply = cleanRemoteChanges.Concat(nonConflictsFromDetection).Concat(resolvedChanges);
                        
                        if (changesToApply.Any())
                        {
                            await _localProvider.ApplyChangesAsync(tableName, changesToApply);
                        }
                    }
                    
                    // After processing each table, update the timestamp to mark progress.
                    // This makes the sync process more resilient to interruptions.
                    await SetLastSyncTimestampAsync(syncStartTime);
                }

                onProgress?.Invoke(100, "Synchronization finished.");

                return new SyncResult { Success = true, UnresolvedConflicts = allUnresolvedConflicts, Message = "Synchronization completed successfully." };
            }
            catch (Exception ex)
            {
                return new SyncResult { Success = false, Error = ex, Message = ex.Message };
            }
        }

                private async Task<DateTime?> GetLastSyncTimestampAsync()
        {
            var timestampStr = await _localProvider.GetParameterAsync("LastSyncTimestamp");
            if (timestampStr != null && DateTime.TryParse(timestampStr, out var timestamp))
            {
                return timestamp;
            }
            return null;
        }

        private async Task SetLastSyncTimestampAsync(DateTime timestamp)
        {
            await _localProvider.SetParameterAsync("LastSyncTimestamp", timestamp.ToString("o")); // ISO 8601 format
        }
    }
}


====================================================================================================

